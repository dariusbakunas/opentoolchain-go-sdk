/**
 * (C) Copyright IBM Corp. 2021.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * IBM OpenAPI SDK Code Generator Version: 99-SNAPSHOT-a675267a-20210510-153046
 */

// Package opentoolchainv1 : Operations and models for the OpenToolchainV1 service
package opentoolchainv1

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"time"

	"github.com/IBM/go-sdk-core/v5/core"
	common "github.com/dariusbakunas/opentoolchain-go-sdk/common"
	"github.com/go-openapi/strfmt"
)

// OpenToolchainV1 : No description provided (generated by Openapi Generator
// https://github.com/openapitools/openapi-generator)
//
// Version: 1.0.0
type OpenToolchainV1 struct {
	Service *core.BaseService
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https:"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "open_toolchain"

// OpenToolchainV1Options : Service options
type OpenToolchainV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator
}

// NewOpenToolchainV1UsingExternalConfig : constructs an instance of OpenToolchainV1 with passed in options and external configuration.
func NewOpenToolchainV1UsingExternalConfig(options *OpenToolchainV1Options) (openToolchain *OpenToolchainV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	openToolchain, err = NewOpenToolchainV1(options)
	if err != nil {
		return
	}

	err = openToolchain.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = openToolchain.Service.SetServiceURL(options.URL)
	}
	return
}

// NewOpenToolchainV1 : constructs an instance of OpenToolchainV1 with passed in options.
func NewOpenToolchainV1(options *OpenToolchainV1Options) (service *OpenToolchainV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	service = &OpenToolchainV1{
		Service: baseService,
	}

	return
}

// GetServiceURLForRegion returns the service URL to be used for the specified region
func GetServiceURLForRegion(region string) (string, error) {
	return "", fmt.Errorf("service does not support regional URLs")
}

// Clone makes a copy of "openToolchain" suitable for processing requests.
func (openToolchain *OpenToolchainV1) Clone() *OpenToolchainV1 {
	if core.IsNil(openToolchain) {
		return nil
	}
	clone := *openToolchain
	clone.Service = openToolchain.Service.Clone()
	return &clone
}

// SetServiceURL sets the service URL
func (openToolchain *OpenToolchainV1) SetServiceURL(url string) error {
	return openToolchain.Service.SetServiceURL(url)
}

// GetServiceURL returns the service URL
func (openToolchain *OpenToolchainV1) GetServiceURL() string {
	return openToolchain.Service.GetServiceURL()
}

// SetDefaultHeaders sets HTTP headers to be sent in every request
func (openToolchain *OpenToolchainV1) SetDefaultHeaders(headers http.Header) {
	openToolchain.Service.SetDefaultHeaders(headers)
}

// SetEnableGzipCompression sets the service's EnableGzipCompression field
func (openToolchain *OpenToolchainV1) SetEnableGzipCompression(enableGzip bool) {
	openToolchain.Service.SetEnableGzipCompression(enableGzip)
}

// GetEnableGzipCompression returns the service's EnableGzipCompression field
func (openToolchain *OpenToolchainV1) GetEnableGzipCompression() bool {
	return openToolchain.Service.GetEnableGzipCompression()
}

// EnableRetries enables automatic retries for requests invoked for this service instance.
// If either parameter is specified as 0, then a default value is used instead.
func (openToolchain *OpenToolchainV1) EnableRetries(maxRetries int, maxRetryInterval time.Duration) {
	openToolchain.Service.EnableRetries(maxRetries, maxRetryInterval)
}

// DisableRetries disables automatic retries for requests invoked for this service instance.
func (openToolchain *OpenToolchainV1) DisableRetries() {
	openToolchain.Service.DisableRetries()
}

// PatchToolchain : Update toolchain parameters
func (openToolchain *OpenToolchainV1) PatchToolchain(patchToolchainOptions *PatchToolchainOptions) (response *core.DetailedResponse, err error) {
	return openToolchain.PatchToolchainWithContext(context.Background(), patchToolchainOptions)
}

// PatchToolchainWithContext is an alternate form of the PatchToolchain method which supports a Context parameter
func (openToolchain *OpenToolchainV1) PatchToolchainWithContext(ctx context.Context, patchToolchainOptions *PatchToolchainOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(patchToolchainOptions, "patchToolchainOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(patchToolchainOptions, "patchToolchainOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"region": *patchToolchainOptions.Region,
		"guid":   *patchToolchainOptions.GUID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/devops-api.{region}.devops.cloud.ibm.com/v1/toolchains/{guid}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range patchToolchainOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "PatchToolchain")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if patchToolchainOptions.Name != nil {
		body["name"] = patchToolchainOptions.Name
	}
	if patchToolchainOptions.Description != nil {
		body["description"] = patchToolchainOptions.Description
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = openToolchain.Service.Request(request, nil)

	return
}

// DeleteToolchain : The DeleteToolchain operation.
// Delete existing toolchain.
func (openToolchain *OpenToolchainV1) DeleteToolchain(deleteToolchainOptions *DeleteToolchainOptions) (response *core.DetailedResponse, err error) {
	return openToolchain.DeleteToolchainWithContext(context.Background(), deleteToolchainOptions)
}

// DeleteToolchainWithContext is an alternate form of the DeleteToolchain method which supports a Context parameter
func (openToolchain *OpenToolchainV1) DeleteToolchainWithContext(ctx context.Context, deleteToolchainOptions *DeleteToolchainOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteToolchainOptions, "deleteToolchainOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteToolchainOptions, "deleteToolchainOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"region": *deleteToolchainOptions.Region,
		"guid":   *deleteToolchainOptions.GUID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/devops-api.{region}.devops.cloud.ibm.com/v1/toolchains/{guid}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteToolchainOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "DeleteToolchain")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	if deleteToolchainOptions.UnbindDeprovisionTools != nil {
		builder.AddQuery("unbind_deprovision_tools", fmt.Sprint(*deleteToolchainOptions.UnbindDeprovisionTools))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = openToolchain.Service.Request(request, nil)

	return
}

// CreateToolchain : Headless Toolchain Creation/Update using POST
// This info is from the document:-
//   https://github.com/open-toolchain/sdk/wiki/Toolchain-Creation-page-parameters.
func (openToolchain *OpenToolchainV1) CreateToolchain(createToolchainOptions *CreateToolchainOptions) (response *core.DetailedResponse, err error) {
	return openToolchain.CreateToolchainWithContext(context.Background(), createToolchainOptions)
}

// CreateToolchainWithContext is an alternate form of the CreateToolchain method which supports a Context parameter
func (openToolchain *OpenToolchainV1) CreateToolchainWithContext(ctx context.Context, createToolchainOptions *CreateToolchainOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createToolchainOptions, "createToolchainOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createToolchainOptions, "createToolchainOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/cloud.ibm.com/devops/setup/deploy`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createToolchainOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "CreateToolchain")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddHeader("Content-Type", "application/x-www-form-urlencoded")

	builder.AddQuery("env_id", fmt.Sprint(*createToolchainOptions.EnvID))

	builder.AddFormData("repository", "", "", fmt.Sprint(*createToolchainOptions.Repository))
	if createToolchainOptions.Autocreate != nil {
		builder.AddFormData("autocreate", "", "", fmt.Sprint(*createToolchainOptions.Autocreate))
	}
	if createToolchainOptions.ResourceGroupID != nil {
		builder.AddFormData("resourceGroupId", "", "", fmt.Sprint(*createToolchainOptions.ResourceGroupID))
	}
	if createToolchainOptions.RepositoryToken != nil {
		builder.AddFormData("repository_token", "", "", fmt.Sprint(*createToolchainOptions.RepositoryToken))
	}
	if createToolchainOptions.Branch != nil {
		builder.AddFormData("branch", "", "", fmt.Sprint(*createToolchainOptions.Branch))
	}

	additionalProps := createToolchainOptions.GetProperties()

	if len(additionalProps) > 0 {
		for k, v := range additionalProps {
			builder.AddFormData(k, "", "", v)
		}
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = openToolchain.Service.Request(request, nil)

	return
}

// CreateServiceInstance : Service Instance Creation using POST
func (openToolchain *OpenToolchainV1) CreateServiceInstance(createServiceInstanceOptions *CreateServiceInstanceOptions) (result *CreateServiceInstanceResponse, response *core.DetailedResponse, err error) {
	return openToolchain.CreateServiceInstanceWithContext(context.Background(), createServiceInstanceOptions)
}

// CreateServiceInstanceWithContext is an alternate form of the CreateServiceInstance method which supports a Context parameter
func (openToolchain *OpenToolchainV1) CreateServiceInstanceWithContext(ctx context.Context, createServiceInstanceOptions *CreateServiceInstanceOptions) (result *CreateServiceInstanceResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createServiceInstanceOptions, "createServiceInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createServiceInstanceOptions, "createServiceInstanceOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/cloud.ibm.com/devops/service_instances`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createServiceInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "CreateServiceInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("env_id", fmt.Sprint(*createServiceInstanceOptions.EnvID))

	body := make(map[string]interface{})
	if createServiceInstanceOptions.ToolchainID != nil {
		body["toolchainId"] = createServiceInstanceOptions.ToolchainID
	}
	if createServiceInstanceOptions.ServiceID != nil {
		body["serviceId"] = createServiceInstanceOptions.ServiceID
	}
	if createServiceInstanceOptions.Parameters != nil {
		body["parameters"] = createServiceInstanceOptions.Parameters
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = openToolchain.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCreateServiceInstanceResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteServiceInstance : The DeleteServiceInstance operation.
// Delete service instance.
func (openToolchain *OpenToolchainV1) DeleteServiceInstance(deleteServiceInstanceOptions *DeleteServiceInstanceOptions) (response *core.DetailedResponse, err error) {
	return openToolchain.DeleteServiceInstanceWithContext(context.Background(), deleteServiceInstanceOptions)
}

// DeleteServiceInstanceWithContext is an alternate form of the DeleteServiceInstance method which supports a Context parameter
func (openToolchain *OpenToolchainV1) DeleteServiceInstanceWithContext(ctx context.Context, deleteServiceInstanceOptions *DeleteServiceInstanceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteServiceInstanceOptions, "deleteServiceInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteServiceInstanceOptions, "deleteServiceInstanceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"guid": *deleteServiceInstanceOptions.GUID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/cloud.ibm.com/devops/service_instances/{guid}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteServiceInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "DeleteServiceInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("env_id", fmt.Sprint(*deleteServiceInstanceOptions.EnvID))

	body := make(map[string]interface{})
	if deleteServiceInstanceOptions.ToolchainID != nil {
		body["toolchainId"] = deleteServiceInstanceOptions.ToolchainID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = openToolchain.Service.Request(request, nil)

	return
}

// PatchServiceInstance : Patch service instance
func (openToolchain *OpenToolchainV1) PatchServiceInstance(patchServiceInstanceOptions *PatchServiceInstanceOptions) (response *core.DetailedResponse, err error) {
	return openToolchain.PatchServiceInstanceWithContext(context.Background(), patchServiceInstanceOptions)
}

// PatchServiceInstanceWithContext is an alternate form of the PatchServiceInstance method which supports a Context parameter
func (openToolchain *OpenToolchainV1) PatchServiceInstanceWithContext(ctx context.Context, patchServiceInstanceOptions *PatchServiceInstanceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(patchServiceInstanceOptions, "patchServiceInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(patchServiceInstanceOptions, "patchServiceInstanceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"guid": *patchServiceInstanceOptions.GUID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/cloud.ibm.com/devops/service_instances/{guid}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range patchServiceInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "PatchServiceInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("env_id", fmt.Sprint(*patchServiceInstanceOptions.EnvID))

	body := make(map[string]interface{})
	if patchServiceInstanceOptions.ToolchainID != nil {
		body["toolchainId"] = patchServiceInstanceOptions.ToolchainID
	}
	if patchServiceInstanceOptions.ServiceID != nil {
		body["service_id"] = patchServiceInstanceOptions.ServiceID
	}
	if patchServiceInstanceOptions.Parameters != nil {
		body["parameters"] = patchServiceInstanceOptions.Parameters
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = openToolchain.Service.Request(request, nil)

	return
}

// GetServiceInstance : Returns details about a particular service instance
func (openToolchain *OpenToolchainV1) GetServiceInstance(getServiceInstanceOptions *GetServiceInstanceOptions) (result *GetServiceInstanceResponse, response *core.DetailedResponse, err error) {
	return openToolchain.GetServiceInstanceWithContext(context.Background(), getServiceInstanceOptions)
}

// GetServiceInstanceWithContext is an alternate form of the GetServiceInstance method which supports a Context parameter
func (openToolchain *OpenToolchainV1) GetServiceInstanceWithContext(ctx context.Context, getServiceInstanceOptions *GetServiceInstanceOptions) (result *GetServiceInstanceResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getServiceInstanceOptions, "getServiceInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getServiceInstanceOptions, "getServiceInstanceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"guid": *getServiceInstanceOptions.GUID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/cloud.ibm.com/devops/service_instances/{guid}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getServiceInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "GetServiceInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("env_id", fmt.Sprint(*getServiceInstanceOptions.EnvID))
	builder.AddQuery("toolchainId", fmt.Sprint(*getServiceInstanceOptions.ToolchainID))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = openToolchain.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetServiceInstanceResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetTektonPipeline : Returns details about a particular tekton pipeline
func (openToolchain *OpenToolchainV1) GetTektonPipeline(getTektonPipelineOptions *GetTektonPipelineOptions) (result *TektonPipeline, response *core.DetailedResponse, err error) {
	return openToolchain.GetTektonPipelineWithContext(context.Background(), getTektonPipelineOptions)
}

// GetTektonPipelineWithContext is an alternate form of the GetTektonPipeline method which supports a Context parameter
func (openToolchain *OpenToolchainV1) GetTektonPipelineWithContext(ctx context.Context, getTektonPipelineOptions *GetTektonPipelineOptions) (result *TektonPipeline, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTektonPipelineOptions, "getTektonPipelineOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getTektonPipelineOptions, "getTektonPipelineOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"guid":   *getTektonPipelineOptions.GUID,
		"region": *getTektonPipelineOptions.Region,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/devops-api.{region}.devops.cloud.ibm.com/v1/tekton-pipelines/{guid}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getTektonPipelineOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "GetTektonPipeline")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = openToolchain.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTektonPipeline)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PatchTektonPipeline : Update tekton pipeline parameters
func (openToolchain *OpenToolchainV1) PatchTektonPipeline(patchTektonPipelineOptions *PatchTektonPipelineOptions) (result *TektonPipeline, response *core.DetailedResponse, err error) {
	return openToolchain.PatchTektonPipelineWithContext(context.Background(), patchTektonPipelineOptions)
}

// PatchTektonPipelineWithContext is an alternate form of the PatchTektonPipeline method which supports a Context parameter
func (openToolchain *OpenToolchainV1) PatchTektonPipelineWithContext(ctx context.Context, patchTektonPipelineOptions *PatchTektonPipelineOptions) (result *TektonPipeline, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(patchTektonPipelineOptions, "patchTektonPipelineOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(patchTektonPipelineOptions, "patchTektonPipelineOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"guid":   *patchTektonPipelineOptions.GUID,
		"region": *patchTektonPipelineOptions.Region,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/devops-api.{region}.devops.cloud.ibm.com/v1/tekton-pipelines/{guid}/config`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range patchTektonPipelineOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "PatchTektonPipeline")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if patchTektonPipelineOptions.Worker != nil {
		body["worker"] = patchTektonPipelineOptions.Worker
	}
	if patchTektonPipelineOptions.EnvProperties != nil {
		body["envProperties"] = patchTektonPipelineOptions.EnvProperties
	}
	if patchTektonPipelineOptions.Inputs != nil {
		body["inputs"] = patchTektonPipelineOptions.Inputs
	}
	if patchTektonPipelineOptions.Triggers != nil {
		body["triggers"] = patchTektonPipelineOptions.Triggers
	}
	if patchTektonPipelineOptions.PipelineDefinitionID != nil {
		body["pipelineDefinitionId"] = patchTektonPipelineOptions.PipelineDefinitionID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = openToolchain.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTektonPipeline)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetTektonPipelineDefinition : Get tekton pipeline definition
func (openToolchain *OpenToolchainV1) GetTektonPipelineDefinition(getTektonPipelineDefinitionOptions *GetTektonPipelineDefinitionOptions) (result *GetTektonPipelineDefinitionResponse, response *core.DetailedResponse, err error) {
	return openToolchain.GetTektonPipelineDefinitionWithContext(context.Background(), getTektonPipelineDefinitionOptions)
}

// GetTektonPipelineDefinitionWithContext is an alternate form of the GetTektonPipelineDefinition method which supports a Context parameter
func (openToolchain *OpenToolchainV1) GetTektonPipelineDefinitionWithContext(ctx context.Context, getTektonPipelineDefinitionOptions *GetTektonPipelineDefinitionOptions) (result *GetTektonPipelineDefinitionResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTektonPipelineDefinitionOptions, "getTektonPipelineDefinitionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getTektonPipelineDefinitionOptions, "getTektonPipelineDefinitionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"guid": *getTektonPipelineDefinitionOptions.GUID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/devops-api.{region}.devops.cloud.ibm.com/v1/tekton-pipelines/{guid}/definition`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getTektonPipelineDefinitionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "GetTektonPipelineDefinition")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("env_id", fmt.Sprint(*getTektonPipelineDefinitionOptions.EnvID))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = openToolchain.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetTektonPipelineDefinitionResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateTektonPipelineDefinition : Create tekton pipeline definition
func (openToolchain *OpenToolchainV1) CreateTektonPipelineDefinition(createTektonPipelineDefinitionOptions *CreateTektonPipelineDefinitionOptions) (result *CreateTektonPipelineDefinitionResponse, response *core.DetailedResponse, err error) {
	return openToolchain.CreateTektonPipelineDefinitionWithContext(context.Background(), createTektonPipelineDefinitionOptions)
}

// CreateTektonPipelineDefinitionWithContext is an alternate form of the CreateTektonPipelineDefinition method which supports a Context parameter
func (openToolchain *OpenToolchainV1) CreateTektonPipelineDefinitionWithContext(ctx context.Context, createTektonPipelineDefinitionOptions *CreateTektonPipelineDefinitionOptions) (result *CreateTektonPipelineDefinitionResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createTektonPipelineDefinitionOptions, "createTektonPipelineDefinitionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createTektonPipelineDefinitionOptions, "createTektonPipelineDefinitionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"guid": *createTektonPipelineDefinitionOptions.GUID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/devops-api.{region}.devops.cloud.ibm.com/v1/tekton-pipelines/{guid}/definition`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createTektonPipelineDefinitionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "CreateTektonPipelineDefinition")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("env_id", fmt.Sprint(*createTektonPipelineDefinitionOptions.EnvID))

	body := make(map[string]interface{})
	if createTektonPipelineDefinitionOptions.Inputs != nil {
		body["inputs"] = createTektonPipelineDefinitionOptions.Inputs
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = openToolchain.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCreateTektonPipelineDefinitionResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetToolchain : Returns details about a particular toolchain
func (openToolchain *OpenToolchainV1) GetToolchain(getToolchainOptions *GetToolchainOptions) (result *ToolchainResponse, response *core.DetailedResponse, err error) {
	return openToolchain.GetToolchainWithContext(context.Background(), getToolchainOptions)
}

// GetToolchainWithContext is an alternate form of the GetToolchain method which supports a Context parameter
func (openToolchain *OpenToolchainV1) GetToolchainWithContext(ctx context.Context, getToolchainOptions *GetToolchainOptions) (result *ToolchainResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getToolchainOptions, "getToolchainOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getToolchainOptions, "getToolchainOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"region": *getToolchainOptions.Region,
		"guid":   *getToolchainOptions.GUID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/devops-api.{region}.devops.cloud.ibm.com/v1/toolchains/{guid}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getToolchainOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "GetToolchain")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if getToolchainOptions.Include != nil {
		builder.AddQuery("include", fmt.Sprint(*getToolchainOptions.Include))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = openToolchain.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalToolchainResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// Container : Container struct
type Container struct {
	GUID *string `json:"guid,omitempty"`

	Type *string `json:"type,omitempty"`
}

// UnmarshalContainer unmarshals an instance of Container from the specified map of raw messages.
func UnmarshalContainer(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Container)
	err = core.UnmarshalPrimitive(m, "guid", &obj.GUID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateServiceInstanceOptions : The CreateServiceInstance options.
type CreateServiceInstanceOptions struct {
	// Environment ID.
	EnvID *string `validate:"required"`

	ToolchainID *string

	ServiceID *string

	Parameters *CreateServiceInstanceParamsParameters

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateServiceInstanceOptions : Instantiate CreateServiceInstanceOptions
func (*OpenToolchainV1) NewCreateServiceInstanceOptions(envID string) *CreateServiceInstanceOptions {
	return &CreateServiceInstanceOptions{
		EnvID: core.StringPtr(envID),
	}
}

// SetEnvID : Allow user to set EnvID
func (options *CreateServiceInstanceOptions) SetEnvID(envID string) *CreateServiceInstanceOptions {
	options.EnvID = core.StringPtr(envID)
	return options
}

// SetToolchainID : Allow user to set ToolchainID
func (options *CreateServiceInstanceOptions) SetToolchainID(toolchainID string) *CreateServiceInstanceOptions {
	options.ToolchainID = core.StringPtr(toolchainID)
	return options
}

// SetServiceID : Allow user to set ServiceID
func (options *CreateServiceInstanceOptions) SetServiceID(serviceID string) *CreateServiceInstanceOptions {
	options.ServiceID = core.StringPtr(serviceID)
	return options
}

// SetParameters : Allow user to set Parameters
func (options *CreateServiceInstanceOptions) SetParameters(parameters *CreateServiceInstanceParamsParameters) *CreateServiceInstanceOptions {
	options.Parameters = parameters
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateServiceInstanceOptions) SetHeaders(param map[string]string) *CreateServiceInstanceOptions {
	options.Headers = param
	return options
}

// CreateServiceInstanceParamsParameters : CreateServiceInstanceParamsParameters struct
type CreateServiceInstanceParamsParameters struct {
	APIKey *string `json:"api_key,omitempty"`

	ServiceKey *string `json:"service_key,omitempty"`

	KeyType *string `json:"key_type,omitempty"`

	ServiceID *string `json:"service_id,omitempty"`

	ServiceName *string `json:"service_name,omitempty"`

	ServiceURL *string `json:"service_url,omitempty"`

	UserEmail *string `json:"user_email,omitempty"`

	UserPhone *string `json:"user_phone,omitempty"`

	Authorized *string `json:"authorized,omitempty"`

	ChannelName *string `json:"channel_name,omitempty"`

	TeamURL *string `json:"team_url,omitempty"`

	PipelineStart *bool `json:"pipeline_start,omitempty"`

	PipelineSuccess *bool `json:"pipeline_success,omitempty"`

	PipelineFail *bool `json:"pipeline_fail,omitempty"`

	ToolchainBind *bool `json:"toolchain_bind,omitempty"`

	ToolchainUnbind *bool `json:"toolchain_unbind,omitempty"`

	APIToken *string `json:"api_token,omitempty"`

	GitID *string `json:"git_id,omitempty"`

	APIRootURL *string `json:"api_root_url,omitempty"`

	Legal *bool `json:"legal,omitempty"`

	RepoURL *string `json:"repo_url,omitempty"`

	TokenURL *string `json:"token_url,omitempty"`

	PrivateRepo *bool `json:"private_repo,omitempty"`

	HasIssues *bool `json:"has_issues,omitempty"`

	InstanceName *string `json:"instance-name,omitempty"`

	IntegrationStatus *string `json:"integration-status,omitempty"`

	Region *string `json:"region,omitempty"`

	ResourceGroup *string `json:"resource-group,omitempty"`

	EnableTraceability *bool `json:"enable_traceability,omitempty"`

	Name *string `json:"name,omitempty"`

	Type *string `json:"type,omitempty"`

	UIPipeline *bool `json:"ui_pipeline,omitempty"`
}

// UnmarshalCreateServiceInstanceParamsParameters unmarshals an instance of CreateServiceInstanceParamsParameters from the specified map of raw messages.
func UnmarshalCreateServiceInstanceParamsParameters(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CreateServiceInstanceParamsParameters)
	err = core.UnmarshalPrimitive(m, "api_key", &obj.APIKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_key", &obj.ServiceKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "key_type", &obj.KeyType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_id", &obj.ServiceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_name", &obj.ServiceName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_url", &obj.ServiceURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_email", &obj.UserEmail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_phone", &obj.UserPhone)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "authorized", &obj.Authorized)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "channel_name", &obj.ChannelName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "team_url", &obj.TeamURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pipeline_start", &obj.PipelineStart)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pipeline_success", &obj.PipelineSuccess)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pipeline_fail", &obj.PipelineFail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "toolchain_bind", &obj.ToolchainBind)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "toolchain_unbind", &obj.ToolchainUnbind)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "api_token", &obj.APIToken)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "git_id", &obj.GitID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "api_root_url", &obj.APIRootURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "legal", &obj.Legal)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "repo_url", &obj.RepoURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "token_url", &obj.TokenURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "private_repo", &obj.PrivateRepo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "has_issues", &obj.HasIssues)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instance-name", &obj.InstanceName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "integration-status", &obj.IntegrationStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource-group", &obj.ResourceGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable_traceability", &obj.EnableTraceability)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ui_pipeline", &obj.UIPipeline)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateServiceInstanceResponse : CreateServiceInstanceResponse struct
type CreateServiceInstanceResponse struct {
	Status *string `json:"status,omitempty"`
}

// UnmarshalCreateServiceInstanceResponse unmarshals an instance of CreateServiceInstanceResponse from the specified map of raw messages.
func UnmarshalCreateServiceInstanceResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CreateServiceInstanceResponse)
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateTektonPipelineDefinitionOptions : The CreateTektonPipelineDefinition options.
type CreateTektonPipelineDefinitionOptions struct {
	// GUID of the pipeline.
	GUID *string `validate:"required,ne="`

	// Environment ID.
	EnvID *string `validate:"required"`

	Inputs []CreateTektonPipelineDefinitionParamsInputsItem

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateTektonPipelineDefinitionOptions : Instantiate CreateTektonPipelineDefinitionOptions
func (*OpenToolchainV1) NewCreateTektonPipelineDefinitionOptions(guid string, envID string) *CreateTektonPipelineDefinitionOptions {
	return &CreateTektonPipelineDefinitionOptions{
		GUID:  core.StringPtr(guid),
		EnvID: core.StringPtr(envID),
	}
}

// SetGUID : Allow user to set GUID
func (options *CreateTektonPipelineDefinitionOptions) SetGUID(guid string) *CreateTektonPipelineDefinitionOptions {
	options.GUID = core.StringPtr(guid)
	return options
}

// SetEnvID : Allow user to set EnvID
func (options *CreateTektonPipelineDefinitionOptions) SetEnvID(envID string) *CreateTektonPipelineDefinitionOptions {
	options.EnvID = core.StringPtr(envID)
	return options
}

// SetInputs : Allow user to set Inputs
func (options *CreateTektonPipelineDefinitionOptions) SetInputs(inputs []CreateTektonPipelineDefinitionParamsInputsItem) *CreateTektonPipelineDefinitionOptions {
	options.Inputs = inputs
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateTektonPipelineDefinitionOptions) SetHeaders(param map[string]string) *CreateTektonPipelineDefinitionOptions {
	options.Headers = param
	return options
}

// CreateTektonPipelineDefinitionParamsInputsItem : CreateTektonPipelineDefinitionParamsInputsItem struct
type CreateTektonPipelineDefinitionParamsInputsItem struct {
	ScmSource *CreateTektonPipelineDefinitionParamsInputsItemScmSource `json:"scmSource,omitempty"`

	Type *string `json:"type,omitempty"`

	ServiceInstanceID *string `json:"serviceInstanceId,omitempty"`

	ShardDefinitionID *string `json:"shardDefinitionId,omitempty"`
}

// UnmarshalCreateTektonPipelineDefinitionParamsInputsItem unmarshals an instance of CreateTektonPipelineDefinitionParamsInputsItem from the specified map of raw messages.
func UnmarshalCreateTektonPipelineDefinitionParamsInputsItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CreateTektonPipelineDefinitionParamsInputsItem)
	err = core.UnmarshalModel(m, "scmSource", &obj.ScmSource, UnmarshalCreateTektonPipelineDefinitionParamsInputsItemScmSource)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serviceInstanceId", &obj.ServiceInstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "shardDefinitionId", &obj.ShardDefinitionID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateTektonPipelineDefinitionParamsInputsItemScmSource : CreateTektonPipelineDefinitionParamsInputsItemScmSource struct
type CreateTektonPipelineDefinitionParamsInputsItemScmSource struct {
	Path *string `json:"path,omitempty"`

	URL *string `json:"url,omitempty"`

	Type *string `json:"type,omitempty"`

	BlindConnection *bool `json:"blindConnection,omitempty"`

	Branch *string `json:"branch,omitempty"`
}

// UnmarshalCreateTektonPipelineDefinitionParamsInputsItemScmSource unmarshals an instance of CreateTektonPipelineDefinitionParamsInputsItemScmSource from the specified map of raw messages.
func UnmarshalCreateTektonPipelineDefinitionParamsInputsItemScmSource(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CreateTektonPipelineDefinitionParamsInputsItemScmSource)
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "blindConnection", &obj.BlindConnection)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "branch", &obj.Branch)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateTektonPipelineDefinitionResponse : CreateTektonPipelineDefinitionResponse struct
type CreateTektonPipelineDefinitionResponse struct {
	Definition *CreateTektonPipelineDefinitionResponseDefinition `json:"definition,omitempty"`

	Inputs []TektonPipelineInput `json:"inputs,omitempty"`
}

// UnmarshalCreateTektonPipelineDefinitionResponse unmarshals an instance of CreateTektonPipelineDefinitionResponse from the specified map of raw messages.
func UnmarshalCreateTektonPipelineDefinitionResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CreateTektonPipelineDefinitionResponse)
	err = core.UnmarshalModel(m, "definition", &obj.Definition, UnmarshalCreateTektonPipelineDefinitionResponseDefinition)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "inputs", &obj.Inputs, UnmarshalTektonPipelineInput)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateTektonPipelineDefinitionResponseDefinition : CreateTektonPipelineDefinitionResponseDefinition struct
type CreateTektonPipelineDefinitionResponseDefinition struct {
	PipelineID *string `json:"pipelineId,omitempty"`

	RepoURL *string `json:"repoUrl,omitempty"`

	Branch *string `json:"branch,omitempty"`

	Path *string `json:"path,omitempty"`

	Sha *string `json:"sha,omitempty"`

	ID *string `json:"id,omitempty"`
}

// UnmarshalCreateTektonPipelineDefinitionResponseDefinition unmarshals an instance of CreateTektonPipelineDefinitionResponseDefinition from the specified map of raw messages.
func UnmarshalCreateTektonPipelineDefinitionResponseDefinition(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CreateTektonPipelineDefinitionResponseDefinition)
	err = core.UnmarshalPrimitive(m, "pipelineId", &obj.PipelineID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "repoUrl", &obj.RepoURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "branch", &obj.Branch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sha", &obj.Sha)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateToolchainOptions : The CreateToolchain options.
type CreateToolchainOptions struct {
	// Environment ID.
	EnvID *string `validate:"required"`

	// The URL of the Git repository containing the template.
	// (For example:- https://github.com/open-toolchain/simple-toolchain).
	Repository *string `validate:"required"`

	// If this param is not provided, then the creation will be ignored and it will just load the toolchain creation page.
	Autocreate *bool

	// The GUID of resource group where toolchain will be created. Pass this parameter, if you want to create the toolchain
	// inside the resource group instead of an org.
	ResourceGroupID *string

	// Optional git api token to access template repository.
	RepositoryToken *string

	// The Git branch name that the template will be read from. Optional. Defaults to `master`.
	Branch *string

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}

	// Allows users to set headers on API requests
	Headers map[string]string
}

// SetProperty allows the user to set an arbitrary property on an instance of CreateToolchainParams
func (o *CreateToolchainOptions) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of CreateToolchainParams
func (o *CreateToolchainOptions) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// NewCreateToolchainOptions : Instantiate CreateToolchainOptions
func (*OpenToolchainV1) NewCreateToolchainOptions(envID string, repository string) *CreateToolchainOptions {
	return &CreateToolchainOptions{
		EnvID:      core.StringPtr(envID),
		Repository: core.StringPtr(repository),
	}
}

// SetEnvID : Allow user to set EnvID
func (options *CreateToolchainOptions) SetEnvID(envID string) *CreateToolchainOptions {
	options.EnvID = core.StringPtr(envID)
	return options
}

// SetRepository : Allow user to set Repository
func (options *CreateToolchainOptions) SetRepository(repository string) *CreateToolchainOptions {
	options.Repository = core.StringPtr(repository)
	return options
}

// SetAutocreate : Allow user to set Autocreate
func (options *CreateToolchainOptions) SetAutocreate(autocreate bool) *CreateToolchainOptions {
	options.Autocreate = core.BoolPtr(autocreate)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *CreateToolchainOptions) SetResourceGroupID(resourceGroupID string) *CreateToolchainOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetRepositoryToken : Allow user to set RepositoryToken
func (options *CreateToolchainOptions) SetRepositoryToken(repositoryToken string) *CreateToolchainOptions {
	options.RepositoryToken = core.StringPtr(repositoryToken)
	return options
}

// SetBranch : Allow user to set Branch
func (options *CreateToolchainOptions) SetBranch(branch string) *CreateToolchainOptions {
	options.Branch = core.StringPtr(branch)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateToolchainOptions) SetHeaders(param map[string]string) *CreateToolchainOptions {
	options.Headers = param
	return options
}

// DeleteServiceInstanceOptions : The DeleteServiceInstance options.
type DeleteServiceInstanceOptions struct {
	// GUID of the service instance.
	GUID *string `validate:"required,ne="`

	// Environment ID.
	EnvID *string `validate:"required"`

	ToolchainID *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteServiceInstanceOptions : Instantiate DeleteServiceInstanceOptions
func (*OpenToolchainV1) NewDeleteServiceInstanceOptions(guid string, envID string) *DeleteServiceInstanceOptions {
	return &DeleteServiceInstanceOptions{
		GUID:  core.StringPtr(guid),
		EnvID: core.StringPtr(envID),
	}
}

// SetGUID : Allow user to set GUID
func (options *DeleteServiceInstanceOptions) SetGUID(guid string) *DeleteServiceInstanceOptions {
	options.GUID = core.StringPtr(guid)
	return options
}

// SetEnvID : Allow user to set EnvID
func (options *DeleteServiceInstanceOptions) SetEnvID(envID string) *DeleteServiceInstanceOptions {
	options.EnvID = core.StringPtr(envID)
	return options
}

// SetToolchainID : Allow user to set ToolchainID
func (options *DeleteServiceInstanceOptions) SetToolchainID(toolchainID string) *DeleteServiceInstanceOptions {
	options.ToolchainID = core.StringPtr(toolchainID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteServiceInstanceOptions) SetHeaders(param map[string]string) *DeleteServiceInstanceOptions {
	options.Headers = param
	return options
}

// DeleteToolchainOptions : The DeleteToolchain options.
type DeleteToolchainOptions struct {
	// Toolchain region.
	Region *string `validate:"required,ne="`

	// GUID of the toolchain.
	GUID *string `validate:"required,ne="`

	// When enabled, unbinds and deprovisions the tools associated with the toolchain.
	UnbindDeprovisionTools *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteToolchainOptions : Instantiate DeleteToolchainOptions
func (*OpenToolchainV1) NewDeleteToolchainOptions(region string, guid string) *DeleteToolchainOptions {
	return &DeleteToolchainOptions{
		Region: core.StringPtr(region),
		GUID:   core.StringPtr(guid),
	}
}

// SetRegion : Allow user to set Region
func (options *DeleteToolchainOptions) SetRegion(region string) *DeleteToolchainOptions {
	options.Region = core.StringPtr(region)
	return options
}

// SetGUID : Allow user to set GUID
func (options *DeleteToolchainOptions) SetGUID(guid string) *DeleteToolchainOptions {
	options.GUID = core.StringPtr(guid)
	return options
}

// SetUnbindDeprovisionTools : Allow user to set UnbindDeprovisionTools
func (options *DeleteToolchainOptions) SetUnbindDeprovisionTools(unbindDeprovisionTools bool) *DeleteToolchainOptions {
	options.UnbindDeprovisionTools = core.BoolPtr(unbindDeprovisionTools)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteToolchainOptions) SetHeaders(param map[string]string) *DeleteToolchainOptions {
	options.Headers = param
	return options
}

// EnvProperty : EnvProperty struct
type EnvProperty struct {
	Name *string `json:"name" validate:"required"`

	Value *string `json:"value" validate:"required"`

	Type *string `json:"type" validate:"required"`
}

// NewEnvProperty : Instantiate EnvProperty (Generic Model Constructor)
func (*OpenToolchainV1) NewEnvProperty(name string, value string, typeVar string) (model *EnvProperty, err error) {
	model = &EnvProperty{
		Name:  core.StringPtr(name),
		Value: core.StringPtr(value),
		Type:  core.StringPtr(typeVar),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalEnvProperty unmarshals an instance of EnvProperty from the specified map of raw messages.
func UnmarshalEnvProperty(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EnvProperty)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetServiceInstanceOptions : The GetServiceInstance options.
type GetServiceInstanceOptions struct {
	// GUID of the service instance.
	GUID *string `validate:"required,ne="`

	// Environment ID.
	EnvID *string `validate:"required"`

	// Toolchain ID.
	ToolchainID *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetServiceInstanceOptions : Instantiate GetServiceInstanceOptions
func (*OpenToolchainV1) NewGetServiceInstanceOptions(guid string, envID string, toolchainID string) *GetServiceInstanceOptions {
	return &GetServiceInstanceOptions{
		GUID:        core.StringPtr(guid),
		EnvID:       core.StringPtr(envID),
		ToolchainID: core.StringPtr(toolchainID),
	}
}

// SetGUID : Allow user to set GUID
func (options *GetServiceInstanceOptions) SetGUID(guid string) *GetServiceInstanceOptions {
	options.GUID = core.StringPtr(guid)
	return options
}

// SetEnvID : Allow user to set EnvID
func (options *GetServiceInstanceOptions) SetEnvID(envID string) *GetServiceInstanceOptions {
	options.EnvID = core.StringPtr(envID)
	return options
}

// SetToolchainID : Allow user to set ToolchainID
func (options *GetServiceInstanceOptions) SetToolchainID(toolchainID string) *GetServiceInstanceOptions {
	options.ToolchainID = core.StringPtr(toolchainID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetServiceInstanceOptions) SetHeaders(param map[string]string) *GetServiceInstanceOptions {
	options.Headers = param
	return options
}

// GetServiceInstanceResponse : GetServiceInstanceResponse struct
type GetServiceInstanceResponse struct {
	ServiceInstance *GetServiceInstanceResponseServiceInstance `json:"serviceInstance,omitempty"`
}

// UnmarshalGetServiceInstanceResponse unmarshals an instance of GetServiceInstanceResponse from the specified map of raw messages.
func UnmarshalGetServiceInstanceResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetServiceInstanceResponse)
	err = core.UnmarshalModel(m, "serviceInstance", &obj.ServiceInstance, UnmarshalGetServiceInstanceResponseServiceInstance)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetServiceInstanceResponseServiceInstance : GetServiceInstanceResponseServiceInstance struct
type GetServiceInstanceResponseServiceInstance struct {
	InstanceID *string `json:"instance_id,omitempty"`

	DashboardURL *string `json:"dashboard_url,omitempty"`

	ServiceID *string `json:"service_id,omitempty"`

	Parameters map[string]interface{} `json:"parameters,omitempty"`
}

// UnmarshalGetServiceInstanceResponseServiceInstance unmarshals an instance of GetServiceInstanceResponseServiceInstance from the specified map of raw messages.
func UnmarshalGetServiceInstanceResponseServiceInstance(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetServiceInstanceResponseServiceInstance)
	err = core.UnmarshalPrimitive(m, "instance_id", &obj.InstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dashboard_url", &obj.DashboardURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_id", &obj.ServiceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "parameters", &obj.Parameters)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetTektonPipelineDefinitionOptions : The GetTektonPipelineDefinition options.
type GetTektonPipelineDefinitionOptions struct {
	// GUID of the pipeline.
	GUID *string `validate:"required,ne="`

	// Environment ID.
	EnvID *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetTektonPipelineDefinitionOptions : Instantiate GetTektonPipelineDefinitionOptions
func (*OpenToolchainV1) NewGetTektonPipelineDefinitionOptions(guid string, envID string) *GetTektonPipelineDefinitionOptions {
	return &GetTektonPipelineDefinitionOptions{
		GUID:  core.StringPtr(guid),
		EnvID: core.StringPtr(envID),
	}
}

// SetGUID : Allow user to set GUID
func (options *GetTektonPipelineDefinitionOptions) SetGUID(guid string) *GetTektonPipelineDefinitionOptions {
	options.GUID = core.StringPtr(guid)
	return options
}

// SetEnvID : Allow user to set EnvID
func (options *GetTektonPipelineDefinitionOptions) SetEnvID(envID string) *GetTektonPipelineDefinitionOptions {
	options.EnvID = core.StringPtr(envID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetTektonPipelineDefinitionOptions) SetHeaders(param map[string]string) *GetTektonPipelineDefinitionOptions {
	options.Headers = param
	return options
}

// GetTektonPipelineDefinitionResponse : GetTektonPipelineDefinitionResponse struct
type GetTektonPipelineDefinitionResponse struct {
	PipelineID *string `json:"pipelineId" validate:"required"`

	RepoURL *string `json:"repoUrl,omitempty"`

	Branch *string `json:"branch,omitempty"`

	Path *string `json:"path,omitempty"`

	Sha *string `json:"sha,omitempty"`

	Type *string `json:"type,omitempty"`

	ID *string `json:"id" validate:"required"`

	ShardRepos []ShardRepo `json:"shardRepos,omitempty"`
}

// UnmarshalGetTektonPipelineDefinitionResponse unmarshals an instance of GetTektonPipelineDefinitionResponse from the specified map of raw messages.
func UnmarshalGetTektonPipelineDefinitionResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetTektonPipelineDefinitionResponse)
	err = core.UnmarshalPrimitive(m, "pipelineId", &obj.PipelineID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "repoUrl", &obj.RepoURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "branch", &obj.Branch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sha", &obj.Sha)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "shardRepos", &obj.ShardRepos, UnmarshalShardRepo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetTektonPipelineOptions : The GetTektonPipeline options.
type GetTektonPipelineOptions struct {
	// GUID of the pipeline.
	GUID *string `validate:"required,ne="`

	// Toolchain region.
	Region *string `validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetTektonPipelineOptions : Instantiate GetTektonPipelineOptions
func (*OpenToolchainV1) NewGetTektonPipelineOptions(guid string, region string) *GetTektonPipelineOptions {
	return &GetTektonPipelineOptions{
		GUID:   core.StringPtr(guid),
		Region: core.StringPtr(region),
	}
}

// SetGUID : Allow user to set GUID
func (options *GetTektonPipelineOptions) SetGUID(guid string) *GetTektonPipelineOptions {
	options.GUID = core.StringPtr(guid)
	return options
}

// SetRegion : Allow user to set Region
func (options *GetTektonPipelineOptions) SetRegion(region string) *GetTektonPipelineOptions {
	options.Region = core.StringPtr(region)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetTektonPipelineOptions) SetHeaders(param map[string]string) *GetTektonPipelineOptions {
	options.Headers = param
	return options
}

// GetToolchainOptions : The GetToolchain options.
type GetToolchainOptions struct {
	// Toolchain region.
	Region *string `validate:"required,ne="`

	// GUID of the toolchain.
	GUID *string `validate:"required,ne="`

	// Instructs the API to return the specified content according to the comma-separated list of sections.
	Include *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetToolchainOptions : Instantiate GetToolchainOptions
func (*OpenToolchainV1) NewGetToolchainOptions(region string, guid string) *GetToolchainOptions {
	return &GetToolchainOptions{
		Region: core.StringPtr(region),
		GUID:   core.StringPtr(guid),
	}
}

// SetRegion : Allow user to set Region
func (options *GetToolchainOptions) SetRegion(region string) *GetToolchainOptions {
	options.Region = core.StringPtr(region)
	return options
}

// SetGUID : Allow user to set GUID
func (options *GetToolchainOptions) SetGUID(guid string) *GetToolchainOptions {
	options.GUID = core.StringPtr(guid)
	return options
}

// SetInclude : Allow user to set Include
func (options *GetToolchainOptions) SetInclude(include string) *GetToolchainOptions {
	options.Include = core.StringPtr(include)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetToolchainOptions) SetHeaders(param map[string]string) *GetToolchainOptions {
	options.Headers = param
	return options
}

// PatchServiceInstanceOptions : The PatchServiceInstance options.
type PatchServiceInstanceOptions struct {
	// GUID of the instance.
	GUID *string `validate:"required,ne="`

	// Environment ID.
	EnvID *string `validate:"required"`

	ToolchainID *string

	ServiceID *string

	Parameters *PatchServiceInstanceParamsParameters

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPatchServiceInstanceOptions : Instantiate PatchServiceInstanceOptions
func (*OpenToolchainV1) NewPatchServiceInstanceOptions(guid string, envID string) *PatchServiceInstanceOptions {
	return &PatchServiceInstanceOptions{
		GUID:  core.StringPtr(guid),
		EnvID: core.StringPtr(envID),
	}
}

// SetGUID : Allow user to set GUID
func (options *PatchServiceInstanceOptions) SetGUID(guid string) *PatchServiceInstanceOptions {
	options.GUID = core.StringPtr(guid)
	return options
}

// SetEnvID : Allow user to set EnvID
func (options *PatchServiceInstanceOptions) SetEnvID(envID string) *PatchServiceInstanceOptions {
	options.EnvID = core.StringPtr(envID)
	return options
}

// SetToolchainID : Allow user to set ToolchainID
func (options *PatchServiceInstanceOptions) SetToolchainID(toolchainID string) *PatchServiceInstanceOptions {
	options.ToolchainID = core.StringPtr(toolchainID)
	return options
}

// SetServiceID : Allow user to set ServiceID
func (options *PatchServiceInstanceOptions) SetServiceID(serviceID string) *PatchServiceInstanceOptions {
	options.ServiceID = core.StringPtr(serviceID)
	return options
}

// SetParameters : Allow user to set Parameters
func (options *PatchServiceInstanceOptions) SetParameters(parameters *PatchServiceInstanceParamsParameters) *PatchServiceInstanceOptions {
	options.Parameters = parameters
	return options
}

// SetHeaders : Allow user to set Headers
func (options *PatchServiceInstanceOptions) SetHeaders(param map[string]string) *PatchServiceInstanceOptions {
	options.Headers = param
	return options
}

// PatchServiceInstanceParamsParameters : PatchServiceInstanceParamsParameters struct
type PatchServiceInstanceParamsParameters struct {
	APIKey *string `json:"api_key,omitempty"`

	ServiceKey *string `json:"service_key,omitempty"`

	KeyType *string `json:"key_type,omitempty"`

	ServiceID *string `json:"service_id,omitempty"`

	ServiceName *string `json:"service_name,omitempty"`

	ServiceURL *string `json:"service_url,omitempty"`

	UserEmail *string `json:"user_email,omitempty"`

	UserPhone *string `json:"user_phone,omitempty"`

	Name *string `json:"name,omitempty"`

	Type *string `json:"type,omitempty"`

	UIPipeline *bool `json:"ui_pipeline,omitempty"`

	RepoURL *string `json:"repo_url,omitempty"`

	PrivateRepo *bool `json:"private_repo,omitempty"`

	HasIssues *bool `json:"has_issues,omitempty"`

	EnableTraceability *bool `json:"enable_traceability,omitempty"`

	InstanceName *string `json:"instance-name,omitempty"`

	IntegrationStatus *string `json:"integration-status,omitempty"`

	Region *string `json:"region,omitempty"`

	ResourceGroup *string `json:"resource-group,omitempty"`

	ChannelName *string `json:"channel_name,omitempty"`

	TeamURL *string `json:"team_url,omitempty"`

	PipelineStart *bool `json:"pipeline_start,omitempty"`

	PipelineSuccess *bool `json:"pipeline_success,omitempty"`

	PipelineFail *bool `json:"pipeline_fail,omitempty"`

	ToolchainBind *bool `json:"toolchain_bind,omitempty"`

	ToolchainUnbind *bool `json:"toolchain_unbind,omitempty"`

	APIToken *string `json:"api_token,omitempty"`
}

// UnmarshalPatchServiceInstanceParamsParameters unmarshals an instance of PatchServiceInstanceParamsParameters from the specified map of raw messages.
func UnmarshalPatchServiceInstanceParamsParameters(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PatchServiceInstanceParamsParameters)
	err = core.UnmarshalPrimitive(m, "api_key", &obj.APIKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_key", &obj.ServiceKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "key_type", &obj.KeyType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_id", &obj.ServiceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_name", &obj.ServiceName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_url", &obj.ServiceURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_email", &obj.UserEmail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_phone", &obj.UserPhone)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ui_pipeline", &obj.UIPipeline)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "repo_url", &obj.RepoURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "private_repo", &obj.PrivateRepo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "has_issues", &obj.HasIssues)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable_traceability", &obj.EnableTraceability)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instance-name", &obj.InstanceName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "integration-status", &obj.IntegrationStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource-group", &obj.ResourceGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "channel_name", &obj.ChannelName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "team_url", &obj.TeamURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pipeline_start", &obj.PipelineStart)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pipeline_success", &obj.PipelineSuccess)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pipeline_fail", &obj.PipelineFail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "toolchain_bind", &obj.ToolchainBind)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "toolchain_unbind", &obj.ToolchainUnbind)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "api_token", &obj.APIToken)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PatchTektonPipelineOptions : The PatchTektonPipeline options.
type PatchTektonPipelineOptions struct {
	// GUID of the pipeline.
	GUID *string `validate:"required,ne="`

	// Toolchain region.
	Region *string `validate:"required,ne="`

	Worker *PatchTektonPipelineParamsWorker

	EnvProperties []EnvProperty

	Inputs []TektonPipelineInput

	Triggers []TektonPipelineTrigger

	PipelineDefinitionID *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPatchTektonPipelineOptions : Instantiate PatchTektonPipelineOptions
func (*OpenToolchainV1) NewPatchTektonPipelineOptions(guid string, region string) *PatchTektonPipelineOptions {
	return &PatchTektonPipelineOptions{
		GUID:   core.StringPtr(guid),
		Region: core.StringPtr(region),
	}
}

// SetGUID : Allow user to set GUID
func (options *PatchTektonPipelineOptions) SetGUID(guid string) *PatchTektonPipelineOptions {
	options.GUID = core.StringPtr(guid)
	return options
}

// SetRegion : Allow user to set Region
func (options *PatchTektonPipelineOptions) SetRegion(region string) *PatchTektonPipelineOptions {
	options.Region = core.StringPtr(region)
	return options
}

// SetWorker : Allow user to set Worker
func (options *PatchTektonPipelineOptions) SetWorker(worker *PatchTektonPipelineParamsWorker) *PatchTektonPipelineOptions {
	options.Worker = worker
	return options
}

// SetEnvProperties : Allow user to set EnvProperties
func (options *PatchTektonPipelineOptions) SetEnvProperties(envProperties []EnvProperty) *PatchTektonPipelineOptions {
	options.EnvProperties = envProperties
	return options
}

// SetInputs : Allow user to set Inputs
func (options *PatchTektonPipelineOptions) SetInputs(inputs []TektonPipelineInput) *PatchTektonPipelineOptions {
	options.Inputs = inputs
	return options
}

// SetTriggers : Allow user to set Triggers
func (options *PatchTektonPipelineOptions) SetTriggers(triggers []TektonPipelineTrigger) *PatchTektonPipelineOptions {
	options.Triggers = triggers
	return options
}

// SetPipelineDefinitionID : Allow user to set PipelineDefinitionID
func (options *PatchTektonPipelineOptions) SetPipelineDefinitionID(pipelineDefinitionID string) *PatchTektonPipelineOptions {
	options.PipelineDefinitionID = core.StringPtr(pipelineDefinitionID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *PatchTektonPipelineOptions) SetHeaders(param map[string]string) *PatchTektonPipelineOptions {
	options.Headers = param
	return options
}

// PatchTektonPipelineParamsWorker : PatchTektonPipelineParamsWorker struct
type PatchTektonPipelineParamsWorker struct {
	WorkerID *string `json:"workerId,omitempty"`

	WorkerName *string `json:"workerName,omitempty"`

	WorkerType *string `json:"workerType,omitempty"`
}

// UnmarshalPatchTektonPipelineParamsWorker unmarshals an instance of PatchTektonPipelineParamsWorker from the specified map of raw messages.
func UnmarshalPatchTektonPipelineParamsWorker(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PatchTektonPipelineParamsWorker)
	err = core.UnmarshalPrimitive(m, "workerId", &obj.WorkerID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerName", &obj.WorkerName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerType", &obj.WorkerType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PatchToolchainOptions : The PatchToolchain options.
type PatchToolchainOptions struct {
	// Toolchain region.
	Region *string `validate:"required,ne="`

	// GUID of the toolchain.
	GUID *string `validate:"required,ne="`

	// Toolchain name.
	Name *string

	Description *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPatchToolchainOptions : Instantiate PatchToolchainOptions
func (*OpenToolchainV1) NewPatchToolchainOptions(region string, guid string) *PatchToolchainOptions {
	return &PatchToolchainOptions{
		Region: core.StringPtr(region),
		GUID:   core.StringPtr(guid),
	}
}

// SetRegion : Allow user to set Region
func (options *PatchToolchainOptions) SetRegion(region string) *PatchToolchainOptions {
	options.Region = core.StringPtr(region)
	return options
}

// SetGUID : Allow user to set GUID
func (options *PatchToolchainOptions) SetGUID(guid string) *PatchToolchainOptions {
	options.GUID = core.StringPtr(guid)
	return options
}

// SetName : Allow user to set Name
func (options *PatchToolchainOptions) SetName(name string) *PatchToolchainOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetDescription : Allow user to set Description
func (options *PatchToolchainOptions) SetDescription(description string) *PatchToolchainOptions {
	options.Description = core.StringPtr(description)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *PatchToolchainOptions) SetHeaders(param map[string]string) *PatchToolchainOptions {
	options.Headers = param
	return options
}

// Service : Service struct
type Service struct {
	BrokerID *string `json:"broker_id,omitempty"`

	ServiceID *string `json:"service_id" validate:"required"`

	Container *Container `json:"container,omitempty"`

	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	Parameters map[string]interface{} `json:"parameters,omitempty"`

	Status *ServiceStatus `json:"status,omitempty"`

	DashboardURL *string `json:"dashboard_url,omitempty"`

	RegionID *string `json:"region_id,omitempty"`

	InstanceID *string `json:"instance_id,omitempty"`

	Description *string `json:"description,omitempty"`

	Tags []string `json:"tags,omitempty"`

	URL *string `json:"url,omitempty"`

	ToolchainBinding *ServiceToolchainBinding `json:"toolchain_binding,omitempty"`
}

// UnmarshalService unmarshals an instance of Service from the specified map of raw messages.
func UnmarshalService(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Service)
	err = core.UnmarshalPrimitive(m, "broker_id", &obj.BrokerID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_id", &obj.ServiceID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "container", &obj.Container, UnmarshalContainer)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "parameters", &obj.Parameters)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "status", &obj.Status, UnmarshalServiceStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dashboard_url", &obj.DashboardURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region_id", &obj.RegionID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instance_id", &obj.InstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tags", &obj.Tags)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "toolchain_binding", &obj.ToolchainBinding, UnmarshalServiceToolchainBinding)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceStatus : ServiceStatus struct
type ServiceStatus struct {
	State *string `json:"state,omitempty"`
}

// UnmarshalServiceStatus unmarshals an instance of ServiceStatus from the specified map of raw messages.
func UnmarshalServiceStatus(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceStatus)
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceToolchainBinding : ServiceToolchainBinding struct
type ServiceToolchainBinding struct {
	Status *ServiceToolchainBindingStatus `json:"status,omitempty"`

	Name *string `json:"name,omitempty"`

	WebhookID *string `json:"webhook_id,omitempty"`
}

// UnmarshalServiceToolchainBinding unmarshals an instance of ServiceToolchainBinding from the specified map of raw messages.
func UnmarshalServiceToolchainBinding(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceToolchainBinding)
	err = core.UnmarshalModel(m, "status", &obj.Status, UnmarshalServiceToolchainBindingStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "webhook_id", &obj.WebhookID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceToolchainBindingStatus : ServiceToolchainBindingStatus struct
type ServiceToolchainBindingStatus struct {
	State *string `json:"state,omitempty"`
}

// UnmarshalServiceToolchainBindingStatus unmarshals an instance of ServiceToolchainBindingStatus from the specified map of raw messages.
func UnmarshalServiceToolchainBindingStatus(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceToolchainBindingStatus)
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ShardRepo : ShardRepo struct
type ShardRepo struct {
	Sha *string `json:"sha,omitempty"`

	ShardDefinitionID *string `json:"shardDefinitionId" validate:"required"`

	RepoURL *string `json:"repoUrl" validate:"required"`

	Path *string `json:"path,omitempty"`
}

// UnmarshalShardRepo unmarshals an instance of ShardRepo from the specified map of raw messages.
func UnmarshalShardRepo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ShardRepo)
	err = core.UnmarshalPrimitive(m, "sha", &obj.Sha)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "shardDefinitionId", &obj.ShardDefinitionID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "repoUrl", &obj.RepoURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TektonPipeline : TektonPipeline struct
type TektonPipeline struct {
	Name *string `json:"name" validate:"required"`

	DashboardURL *string `json:"dashboard_url,omitempty"`

	ResourceGroupID *string `json:"resourceGroupId,omitempty"`

	ID *string `json:"id" validate:"required"`

	ToolchainID *string `json:"toolchainId" validate:"required"`

	PipelineOwner *string `json:"pipelineOwner,omitempty"`

	Enabled *bool `json:"enabled,omitempty"`

	Type *string `json:"type,omitempty"`

	Created *strfmt.DateTime `json:"created,omitempty"`

	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	UpdatedAtTimestamp *float64 `json:"updated_at_timestamp,omitempty"`

	CreatedTimestamp *float64 `json:"created_timestamp,omitempty"`

	EnvProperties []EnvProperty `json:"envProperties" validate:"required"`

	Inputs []TektonPipelineInput `json:"inputs,omitempty"`

	Triggers []TektonPipelineTrigger `json:"triggers,omitempty"`

	Status *string `json:"status,omitempty"`

	URL *string `json:"url,omitempty"`

	RunsURL *string `json:"runs_url,omitempty"`

	ToolchainCRN *string `json:"toolchainCRN,omitempty"`

	PipelineDefinitionID *string `json:"pipelineDefinitionId,omitempty"`
}

// UnmarshalTektonPipeline unmarshals an instance of TektonPipeline from the specified map of raw messages.
func UnmarshalTektonPipeline(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TektonPipeline)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dashboard_url", &obj.DashboardURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceGroupId", &obj.ResourceGroupID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "toolchainId", &obj.ToolchainID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pipelineOwner", &obj.PipelineOwner)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created", &obj.Created)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at_timestamp", &obj.UpdatedAtTimestamp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_timestamp", &obj.CreatedTimestamp)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "envProperties", &obj.EnvProperties, UnmarshalEnvProperty)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "inputs", &obj.Inputs, UnmarshalTektonPipelineInput)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "triggers", &obj.Triggers, UnmarshalTektonPipelineTrigger)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "runs_url", &obj.RunsURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "toolchainCRN", &obj.ToolchainCRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pipelineDefinitionId", &obj.PipelineDefinitionID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TektonPipelineInput : TektonPipelineInput struct
type TektonPipelineInput struct {
	Type *string `json:"type,omitempty"`

	ServiceInstanceID *string `json:"serviceInstanceId,omitempty"`

	ShardDefinitionID *string `json:"shardDefinitionId,omitempty"`

	ScmSource *TektonPipelineInputScmSource `json:"scmSource,omitempty"`
}

// UnmarshalTektonPipelineInput unmarshals an instance of TektonPipelineInput from the specified map of raw messages.
func UnmarshalTektonPipelineInput(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TektonPipelineInput)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serviceInstanceId", &obj.ServiceInstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "shardDefinitionId", &obj.ShardDefinitionID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "scmSource", &obj.ScmSource, UnmarshalTektonPipelineInputScmSource)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TektonPipelineInputScmSource : TektonPipelineInputScmSource struct
type TektonPipelineInputScmSource struct {
	Path *string `json:"path,omitempty"`

	URL *string `json:"url,omitempty"`

	Type *string `json:"type,omitempty"`

	BlindConnection *bool `json:"blindConnection,omitempty"`

	Branch *string `json:"branch,omitempty"`
}

// UnmarshalTektonPipelineInputScmSource unmarshals an instance of TektonPipelineInputScmSource from the specified map of raw messages.
func UnmarshalTektonPipelineInputScmSource(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TektonPipelineInputScmSource)
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "blindConnection", &obj.BlindConnection)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "branch", &obj.Branch)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TektonPipelineTrigger : TektonPipelineTrigger struct
type TektonPipelineTrigger struct {
	ID *string `json:"id,omitempty"`

	Name *string `json:"name,omitempty"`

	EventListener *string `json:"eventListener" validate:"required"`

	Disabled *bool `json:"disabled,omitempty"`

	ScmSource *TektonPipelineTriggerScmSource `json:"scmSource,omitempty"`

	Type *string `json:"type" validate:"required"`

	Events *TektonPipelineTriggerEvents `json:"events,omitempty"`

	ServiceInstanceID *string `json:"serviceInstanceId,omitempty"`
}

// NewTektonPipelineTrigger : Instantiate TektonPipelineTrigger (Generic Model Constructor)
func (*OpenToolchainV1) NewTektonPipelineTrigger(eventListener string, typeVar string) (model *TektonPipelineTrigger, err error) {
	model = &TektonPipelineTrigger{
		EventListener: core.StringPtr(eventListener),
		Type:          core.StringPtr(typeVar),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalTektonPipelineTrigger unmarshals an instance of TektonPipelineTrigger from the specified map of raw messages.
func UnmarshalTektonPipelineTrigger(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TektonPipelineTrigger)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "eventListener", &obj.EventListener)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "disabled", &obj.Disabled)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "scmSource", &obj.ScmSource, UnmarshalTektonPipelineTriggerScmSource)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "events", &obj.Events, UnmarshalTektonPipelineTriggerEvents)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serviceInstanceId", &obj.ServiceInstanceID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TektonPipelineTriggerEvents : TektonPipelineTriggerEvents struct
type TektonPipelineTriggerEvents struct {
	Push *bool `json:"push,omitempty"`

	PullRequest *bool `json:"pull_request,omitempty"`

	PullRequestClosed *bool `json:"pull_request_closed,omitempty"`
}

// UnmarshalTektonPipelineTriggerEvents unmarshals an instance of TektonPipelineTriggerEvents from the specified map of raw messages.
func UnmarshalTektonPipelineTriggerEvents(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TektonPipelineTriggerEvents)
	err = core.UnmarshalPrimitive(m, "push", &obj.Push)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pull_request", &obj.PullRequest)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pull_request_closed", &obj.PullRequestClosed)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TektonPipelineTriggerScmSource : TektonPipelineTriggerScmSource struct
type TektonPipelineTriggerScmSource struct {
	URL *string `json:"url,omitempty"`

	Type *string `json:"type,omitempty"`

	Branch *string `json:"branch,omitempty"`

	Pattern *string `json:"pattern,omitempty"`
}

// UnmarshalTektonPipelineTriggerScmSource unmarshals an instance of TektonPipelineTriggerScmSource from the specified map of raw messages.
func UnmarshalTektonPipelineTriggerScmSource(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TektonPipelineTriggerScmSource)
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "branch", &obj.Branch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pattern", &obj.Pattern)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Toolchain : Toolchain struct
type Toolchain struct {
	ToolchainGUID *string `json:"toolchain_guid" validate:"required"`

	Name *string `json:"name" validate:"required"`

	Description *string `json:"description,omitempty"`

	Key *string `json:"key,omitempty"`

	Container *Container `json:"container,omitempty"`

	CRN *string `json:"crn,omitempty"`

	Created *strfmt.DateTime `json:"created,omitempty"`

	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	Creator *string `json:"creator,omitempty"`

	Generator *string `json:"generator,omitempty"`

	Template *ToolchainTemplate `json:"template,omitempty"`

	Tags []string `json:"tags,omitempty"`

	LifecycleMessagingWebhookID *string `json:"lifecycle_messaging_webhook_id,omitempty"`

	RegionID *string `json:"region_id,omitempty"`

	Services []Service `json:"services,omitempty"`
}

// UnmarshalToolchain unmarshals an instance of Toolchain from the specified map of raw messages.
func UnmarshalToolchain(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Toolchain)
	err = core.UnmarshalPrimitive(m, "toolchain_guid", &obj.ToolchainGUID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "key", &obj.Key)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "container", &obj.Container, UnmarshalContainer)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created", &obj.Created)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "creator", &obj.Creator)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "generator", &obj.Generator)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "template", &obj.Template, UnmarshalToolchainTemplate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tags", &obj.Tags)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_messaging_webhook_id", &obj.LifecycleMessagingWebhookID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region_id", &obj.RegionID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "services", &obj.Services, UnmarshalService)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ToolchainResponse : ToolchainResponse struct
type ToolchainResponse struct {
	TotalResults *float64 `json:"total_results,omitempty"`

	Items []Toolchain `json:"items,omitempty"`
}

// UnmarshalToolchainResponse unmarshals an instance of ToolchainResponse from the specified map of raw messages.
func UnmarshalToolchainResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ToolchainResponse)
	err = core.UnmarshalPrimitive(m, "total_results", &obj.TotalResults)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "items", &obj.Items, UnmarshalToolchain)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ToolchainTemplate : ToolchainTemplate struct
type ToolchainTemplate struct {
	GettingStarted *string `json:"getting_started,omitempty"`

	ServicesTotal *int64 `json:"services_total,omitempty"`

	Name *string `json:"name,omitempty"`

	Type *string `json:"type,omitempty"`

	URL *string `json:"url,omitempty"`

	Source *string `json:"source,omitempty"`

	Locale *string `json:"locale,omitempty"`
}

// UnmarshalToolchainTemplate unmarshals an instance of ToolchainTemplate from the specified map of raw messages.
func UnmarshalToolchainTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ToolchainTemplate)
	err = core.UnmarshalPrimitive(m, "getting_started", &obj.GettingStarted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "services_total", &obj.ServicesTotal)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "locale", &obj.Locale)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}
