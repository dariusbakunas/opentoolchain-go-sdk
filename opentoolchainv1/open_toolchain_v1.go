/**
 * (C) Copyright IBM Corp. 2021.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * IBM OpenAPI SDK Code Generator Version: 3.32.0-4c6a3129-20210514-210323
 */

// Package opentoolchainv1 : Operations and models for the OpenToolchainV1 service
package opentoolchainv1

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"time"

	"github.com/IBM/go-sdk-core/v5/core"
	common "github.com/dariusbakunas/opentoolchain-go-sdk/common"
	"github.com/go-openapi/strfmt"
)

// OpenToolchainV1 : No description provided (generated by Openapi Generator
// https://github.com/openapitools/openapi-generator)
//
// Version: 1.0.0
type OpenToolchainV1 struct {
	Service *core.BaseService
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://cloud.ibm.com"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "open_toolchain"

// OpenToolchainV1Options : Service options
type OpenToolchainV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator
}

// NewOpenToolchainV1UsingExternalConfig : constructs an instance of OpenToolchainV1 with passed in options and external configuration.
func NewOpenToolchainV1UsingExternalConfig(options *OpenToolchainV1Options) (openToolchain *OpenToolchainV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	openToolchain, err = NewOpenToolchainV1(options)
	if err != nil {
		return
	}

	err = openToolchain.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = openToolchain.Service.SetServiceURL(options.URL)
	}
	return
}

// NewOpenToolchainV1 : constructs an instance of OpenToolchainV1 with passed in options.
func NewOpenToolchainV1(options *OpenToolchainV1Options) (service *OpenToolchainV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	service = &OpenToolchainV1{
		Service: baseService,
	}

	return
}

// GetServiceURLForRegion returns the service URL to be used for the specified region
func GetServiceURLForRegion(region string) (string, error) {
	return "", fmt.Errorf("service does not support regional URLs")
}

// Clone makes a copy of "openToolchain" suitable for processing requests.
func (openToolchain *OpenToolchainV1) Clone() *OpenToolchainV1 {
	if core.IsNil(openToolchain) {
		return nil
	}
	clone := *openToolchain
	clone.Service = openToolchain.Service.Clone()
	return &clone
}

// SetServiceURL sets the service URL
func (openToolchain *OpenToolchainV1) SetServiceURL(url string) error {
	return openToolchain.Service.SetServiceURL(url)
}

// GetServiceURL returns the service URL
func (openToolchain *OpenToolchainV1) GetServiceURL() string {
	return openToolchain.Service.GetServiceURL()
}

// SetDefaultHeaders sets HTTP headers to be sent in every request
func (openToolchain *OpenToolchainV1) SetDefaultHeaders(headers http.Header) {
	openToolchain.Service.SetDefaultHeaders(headers)
}

// SetEnableGzipCompression sets the service's EnableGzipCompression field
func (openToolchain *OpenToolchainV1) SetEnableGzipCompression(enableGzip bool) {
	openToolchain.Service.SetEnableGzipCompression(enableGzip)
}

// GetEnableGzipCompression returns the service's EnableGzipCompression field
func (openToolchain *OpenToolchainV1) GetEnableGzipCompression() bool {
	return openToolchain.Service.GetEnableGzipCompression()
}

// EnableRetries enables automatic retries for requests invoked for this service instance.
// If either parameter is specified as 0, then a default value is used instead.
func (openToolchain *OpenToolchainV1) EnableRetries(maxRetries int, maxRetryInterval time.Duration) {
	openToolchain.Service.EnableRetries(maxRetries, maxRetryInterval)
}

// DisableRetries disables automatic retries for requests invoked for this service instance.
func (openToolchain *OpenToolchainV1) DisableRetries() {
	openToolchain.Service.DisableRetries()
}

// DeleteToolchain : The DeleteToolchain operation.
// Delete existing toolchain.
func (openToolchain *OpenToolchainV1) DeleteToolchain(deleteToolchainOptions *DeleteToolchainOptions) (response *core.DetailedResponse, err error) {
	return openToolchain.DeleteToolchainWithContext(context.Background(), deleteToolchainOptions)
}

// DeleteToolchainWithContext is an alternate form of the DeleteToolchain method which supports a Context parameter
func (openToolchain *OpenToolchainV1) DeleteToolchainWithContext(ctx context.Context, deleteToolchainOptions *DeleteToolchainOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteToolchainOptions, "deleteToolchainOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteToolchainOptions, "deleteToolchainOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"guid": *deleteToolchainOptions.GUID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/devops/toolchains/{guid}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteToolchainOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "DeleteToolchain")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("env_id", fmt.Sprint(*deleteToolchainOptions.EnvID))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = openToolchain.Service.Request(request, nil)

	return
}

// CreateToolchain : Headless Toolchain Creation/Update using POST
// This info is from the document:-
//   https://github.com/open-toolchain/sdk/wiki/Toolchain-Creation-page-parameters.
func (openToolchain *OpenToolchainV1) CreateToolchain(createToolchainOptions *CreateToolchainOptions) (response *core.DetailedResponse, err error) {
	return openToolchain.CreateToolchainWithContext(context.Background(), createToolchainOptions)
}

// CreateToolchainWithContext is an alternate form of the CreateToolchain method which supports a Context parameter
func (openToolchain *OpenToolchainV1) CreateToolchainWithContext(ctx context.Context, createToolchainOptions *CreateToolchainOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createToolchainOptions, "createToolchainOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createToolchainOptions, "createToolchainOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/devops/setup/deploy`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createToolchainOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "CreateToolchain")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddHeader("Content-Type", "application/x-www-form-urlencoded")

	builder.AddQuery("env_id", fmt.Sprint(*createToolchainOptions.EnvID))

	builder.AddFormData("repository", "", "", fmt.Sprint(*createToolchainOptions.Repository))
	if createToolchainOptions.Autocreate != nil {
		builder.AddFormData("autocreate", "", "", fmt.Sprint(*createToolchainOptions.Autocreate))
	}
	if createToolchainOptions.ResourceGroupID != nil {
		builder.AddFormData("resourceGroupId", "", "", fmt.Sprint(*createToolchainOptions.ResourceGroupID))
	}
	if createToolchainOptions.RepositoryToken != nil {
		builder.AddFormData("repository_token", "", "", fmt.Sprint(*createToolchainOptions.RepositoryToken))
	}
	if createToolchainOptions.Branch != nil {
		builder.AddFormData("branch", "", "", fmt.Sprint(*createToolchainOptions.Branch))
	}

	additionalProps := createToolchainOptions.GetProperties()

	if len(additionalProps) > 0 {
		for k, v := range additionalProps {
			builder.AddFormData(k, "", "", v)
		}
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	// buf, dumpErr := httputil.DumpRequestOut(request, request.Body != nil)

	// if dumpErr == nil {
	// 	log.Printf("[DEBUG] request: %s", string(buf))
	// }

	response, err = openToolchain.Service.Request(request, nil)

	return
}

// GetToolchain : Returns details about a particular toolchain
func (openToolchain *OpenToolchainV1) GetToolchain(getToolchainOptions *GetToolchainOptions) (result *Toolchain, response *core.DetailedResponse, err error) {
	return openToolchain.GetToolchainWithContext(context.Background(), getToolchainOptions)
}

// GetToolchainWithContext is an alternate form of the GetToolchain method which supports a Context parameter
func (openToolchain *OpenToolchainV1) GetToolchainWithContext(ctx context.Context, getToolchainOptions *GetToolchainOptions) (result *Toolchain, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getToolchainOptions, "getToolchainOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getToolchainOptions, "getToolchainOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"guid": *getToolchainOptions.GUID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/devops/toolchains/{guid}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getToolchainOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "GetToolchain")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("env_id", fmt.Sprint(*getToolchainOptions.EnvID))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = openToolchain.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalToolchain)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// Container : Container struct
type Container struct {
	GUID *string `json:"guid,omitempty"`

	Type *string `json:"type,omitempty"`
}

// UnmarshalContainer unmarshals an instance of Container from the specified map of raw messages.
func UnmarshalContainer(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Container)
	err = core.UnmarshalPrimitive(m, "guid", &obj.GUID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateToolchainOptions : The CreateToolchain options.
type CreateToolchainOptions struct {
	// Environment ID.
	EnvID *string `validate:"required"`

	// The URL of the Git repository containing the template.
	// (For example:- https://github.com/open-toolchain/simple-toolchain).
	Repository *string `validate:"required"`

	// If this param is not provided, then the creation will be ignored  and it will just load the toolchain creation page.
	Autocreate *bool

	// The GUID of resource group where toolchain will be created.  Pass this parameter, if you want to create the
	// toolchain inside the resource group instead of an org.
	ResourceGroupID *string

	// Optional git api token to access template repository.
	RepositoryToken *string

	// The Git branch name that the template will be read from.  Optional. Defaults to `master`.
	Branch *string

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}

	// Allows users to set headers on API requests
	Headers map[string]string
}

// SetProperty allows the user to set an arbitrary property on an instance of CreateToolchainParams
func (o *CreateToolchainOptions) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of CreateToolchainParams
func (o *CreateToolchainOptions) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// NewCreateToolchainOptions : Instantiate CreateToolchainOptions
func (*OpenToolchainV1) NewCreateToolchainOptions(envID string, repository string) *CreateToolchainOptions {
	return &CreateToolchainOptions{
		EnvID:      core.StringPtr(envID),
		Repository: core.StringPtr(repository),
	}
}

// SetEnvID : Allow user to set EnvID
func (options *CreateToolchainOptions) SetEnvID(envID string) *CreateToolchainOptions {
	options.EnvID = core.StringPtr(envID)
	return options
}

// SetRepository : Allow user to set Repository
func (options *CreateToolchainOptions) SetRepository(repository string) *CreateToolchainOptions {
	options.Repository = core.StringPtr(repository)
	return options
}

// SetAutocreate : Allow user to set Autocreate
func (options *CreateToolchainOptions) SetAutocreate(autocreate bool) *CreateToolchainOptions {
	options.Autocreate = core.BoolPtr(autocreate)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *CreateToolchainOptions) SetResourceGroupID(resourceGroupID string) *CreateToolchainOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetRepositoryToken : Allow user to set RepositoryToken
func (options *CreateToolchainOptions) SetRepositoryToken(repositoryToken string) *CreateToolchainOptions {
	options.RepositoryToken = core.StringPtr(repositoryToken)
	return options
}

// SetBranch : Allow user to set Branch
func (options *CreateToolchainOptions) SetBranch(branch string) *CreateToolchainOptions {
	options.Branch = core.StringPtr(branch)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateToolchainOptions) SetHeaders(param map[string]string) *CreateToolchainOptions {
	options.Headers = param
	return options
}

// DeleteToolchainOptions : The DeleteToolchain options.
type DeleteToolchainOptions struct {
	// GUID of the toolchain.
	GUID *string `validate:"required,ne="`

	// Environment ID.
	EnvID *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteToolchainOptions : Instantiate DeleteToolchainOptions
func (*OpenToolchainV1) NewDeleteToolchainOptions(guid string, envID string) *DeleteToolchainOptions {
	return &DeleteToolchainOptions{
		GUID:  core.StringPtr(guid),
		EnvID: core.StringPtr(envID),
	}
}

// SetGUID : Allow user to set GUID
func (options *DeleteToolchainOptions) SetGUID(guid string) *DeleteToolchainOptions {
	options.GUID = core.StringPtr(guid)
	return options
}

// SetEnvID : Allow user to set EnvID
func (options *DeleteToolchainOptions) SetEnvID(envID string) *DeleteToolchainOptions {
	options.EnvID = core.StringPtr(envID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteToolchainOptions) SetHeaders(param map[string]string) *DeleteToolchainOptions {
	options.Headers = param
	return options
}

// GetToolchainOptions : The GetToolchain options.
type GetToolchainOptions struct {
	// GUID of the toolchain.
	GUID *string `validate:"required,ne="`

	// Environment ID.
	EnvID *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetToolchainOptions : Instantiate GetToolchainOptions
func (*OpenToolchainV1) NewGetToolchainOptions(guid string, envID string) *GetToolchainOptions {
	return &GetToolchainOptions{
		GUID:  core.StringPtr(guid),
		EnvID: core.StringPtr(envID),
	}
}

// SetGUID : Allow user to set GUID
func (options *GetToolchainOptions) SetGUID(guid string) *GetToolchainOptions {
	options.GUID = core.StringPtr(guid)
	return options
}

// SetEnvID : Allow user to set EnvID
func (options *GetToolchainOptions) SetEnvID(envID string) *GetToolchainOptions {
	options.EnvID = core.StringPtr(envID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetToolchainOptions) SetHeaders(param map[string]string) *GetToolchainOptions {
	options.Headers = param
	return options
}

// Service : Service struct
type Service struct {
	BrokerID *string `json:"broker_id,omitempty"`

	ServiceID *string `json:"service_id" validate:"required"`

	Container *Container `json:"container,omitempty"`

	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	Parameters ServiceParametersIntf `json:"parameters,omitempty"`

	Status *ServiceStatus `json:"status,omitempty"`

	DashboardURL *string `json:"dashboard_url,omitempty"`

	RegionID *string `json:"region_id,omitempty"`

	InstanceID *string `json:"instance_id,omitempty"`

	Description *string `json:"description,omitempty"`

	Tags []string `json:"tags,omitempty"`

	URL *string `json:"url,omitempty"`

	ToolchainBinding *ServiceToolchainBinding `json:"toolchain_binding,omitempty"`
}

// UnmarshalService unmarshals an instance of Service from the specified map of raw messages.
func UnmarshalService(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Service)
	err = core.UnmarshalPrimitive(m, "broker_id", &obj.BrokerID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_id", &obj.ServiceID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "container", &obj.Container, UnmarshalContainer)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "parameters", &obj.Parameters, UnmarshalServiceParameters)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "status", &obj.Status, UnmarshalServiceStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dashboard_url", &obj.DashboardURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region_id", &obj.RegionID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instance_id", &obj.InstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tags", &obj.Tags)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "toolchain_binding", &obj.ToolchainBinding, UnmarshalServiceToolchainBinding)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceParameters : ServiceParameters struct
// Models which "extend" this model:
// - ServiceParametersSlackParams
// - ServiceParametersGithubIntegratedParams
// - ServiceParametersPipelineParams
// - ServiceParametersPagerDutyParams
type ServiceParameters struct {
	APIToken *string `json:"api_token,omitempty"`

	ChannelName *string `json:"channel_name,omitempty"`

	TeamURL *string `json:"team_url,omitempty"`

	Label *string `json:"label,omitempty"`

	Type *string `json:"type,omitempty"`

	RepoName *string `json:"repo_name,omitempty"`

	RepoURL *string `json:"repo_url,omitempty"`

	PrivateRepo *bool `json:"private_repo,omitempty"`

	HasIssues *bool `json:"has_issues,omitempty"`

	Services *string `json:"services,omitempty"`

	Name *string `json:"name,omitempty"`

	Configuration *string `json:"configuration,omitempty"`

	UIPipeline *bool `json:"ui_pipeline,omitempty"`

	KeyType *string `json:"key_type,omitempty"`

	APIKey *string `json:"api_key,omitempty"`

	ServiceName *string `json:"service_name,omitempty"`

	UserEmail *string `json:"user_email,omitempty"`

	UserPhone *string `json:"user_phone,omitempty"`

	ServiceURL *string `json:"service_url,omitempty"`

	ServiceKey *string `json:"service_key,omitempty"`
}

func (*ServiceParameters) isaServiceParameters() bool {
	return true
}

type ServiceParametersIntf interface {
	isaServiceParameters() bool
}

// UnmarshalServiceParameters unmarshals an instance of ServiceParameters from the specified map of raw messages.
func UnmarshalServiceParameters(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceParameters)
	err = core.UnmarshalPrimitive(m, "api_token", &obj.APIToken)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "channel_name", &obj.ChannelName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "team_url", &obj.TeamURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "label", &obj.Label)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "repo_name", &obj.RepoName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "repo_url", &obj.RepoURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "private_repo", &obj.PrivateRepo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "has_issues", &obj.HasIssues)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "services", &obj.Services)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "configuration", &obj.Configuration)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ui_pipeline", &obj.UIPipeline)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "key_type", &obj.KeyType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "api_key", &obj.APIKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_name", &obj.ServiceName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_email", &obj.UserEmail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_phone", &obj.UserPhone)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_url", &obj.ServiceURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_key", &obj.ServiceKey)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceStatus : ServiceStatus struct
type ServiceStatus struct {
	State *string `json:"state,omitempty"`
}

// UnmarshalServiceStatus unmarshals an instance of ServiceStatus from the specified map of raw messages.
func UnmarshalServiceStatus(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceStatus)
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceToolchainBinding : ServiceToolchainBinding struct
type ServiceToolchainBinding struct {
	Status *ServiceToolchainBindingStatus `json:"status,omitempty"`

	Name *string `json:"name,omitempty"`

	WebhookID *string `json:"webhook_id,omitempty"`
}

// UnmarshalServiceToolchainBinding unmarshals an instance of ServiceToolchainBinding from the specified map of raw messages.
func UnmarshalServiceToolchainBinding(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceToolchainBinding)
	err = core.UnmarshalModel(m, "status", &obj.Status, UnmarshalServiceToolchainBindingStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "webhook_id", &obj.WebhookID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceToolchainBindingStatus : ServiceToolchainBindingStatus struct
type ServiceToolchainBindingStatus struct {
	State *string `json:"state,omitempty"`
}

// UnmarshalServiceToolchainBindingStatus unmarshals an instance of ServiceToolchainBindingStatus from the specified map of raw messages.
func UnmarshalServiceToolchainBindingStatus(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceToolchainBindingStatus)
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Toolchain : Toolchain struct
type Toolchain struct {
	ToolchainGUID *string `json:"toolchain_guid" validate:"required"`

	Name *string `json:"name" validate:"required"`

	Description *string `json:"description,omitempty"`

	Key *string `json:"key,omitempty"`

	Container *Container `json:"container,omitempty"`

	CRN *string `json:"crn,omitempty"`

	Created *strfmt.DateTime `json:"created,omitempty"`

	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	Creator *string `json:"creator,omitempty"`

	Generator *string `json:"generator,omitempty"`

	Template *ToolchainTemplate `json:"template,omitempty"`

	Tags []string `json:"tags,omitempty"`

	LifecycleMessagingWebhookID *string `json:"lifecycle_messaging_webhook_id,omitempty"`

	RegionID *string `json:"region_id,omitempty"`

	Services []Service `json:"services,omitempty"`
}

// UnmarshalToolchain unmarshals an instance of Toolchain from the specified map of raw messages.
func UnmarshalToolchain(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Toolchain)
	err = core.UnmarshalPrimitive(m, "toolchain_guid", &obj.ToolchainGUID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "key", &obj.Key)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "container", &obj.Container, UnmarshalContainer)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created", &obj.Created)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "creator", &obj.Creator)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "generator", &obj.Generator)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "template", &obj.Template, UnmarshalToolchainTemplate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tags", &obj.Tags)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_messaging_webhook_id", &obj.LifecycleMessagingWebhookID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region_id", &obj.RegionID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "services", &obj.Services, UnmarshalService)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ToolchainTemplate : ToolchainTemplate struct
type ToolchainTemplate struct {
	GettingStarted *string `json:"getting_started,omitempty"`

	ServicesTotal *int64 `json:"services_total,omitempty"`

	Name *string `json:"name,omitempty"`

	Type *string `json:"type,omitempty"`

	URL *string `json:"url,omitempty"`

	Source *string `json:"source,omitempty"`

	Locale *string `json:"locale,omitempty"`
}

// UnmarshalToolchainTemplate unmarshals an instance of ToolchainTemplate from the specified map of raw messages.
func UnmarshalToolchainTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ToolchainTemplate)
	err = core.UnmarshalPrimitive(m, "getting_started", &obj.GettingStarted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "services_total", &obj.ServicesTotal)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "locale", &obj.Locale)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceParametersGithubIntegratedParams : ServiceParametersGithubIntegratedParams struct
// This model "extends" ServiceParameters
type ServiceParametersGithubIntegratedParams struct {
	Label *string `json:"label,omitempty"`

	Type *string `json:"type,omitempty"`

	RepoName *string `json:"repo_name,omitempty"`

	RepoURL *string `json:"repo_url,omitempty"`

	PrivateRepo *bool `json:"private_repo,omitempty"`

	HasIssues *bool `json:"has_issues,omitempty"`
}

func (*ServiceParametersGithubIntegratedParams) isaServiceParameters() bool {
	return true
}

// UnmarshalServiceParametersGithubIntegratedParams unmarshals an instance of ServiceParametersGithubIntegratedParams from the specified map of raw messages.
func UnmarshalServiceParametersGithubIntegratedParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceParametersGithubIntegratedParams)
	err = core.UnmarshalPrimitive(m, "label", &obj.Label)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "repo_name", &obj.RepoName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "repo_url", &obj.RepoURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "private_repo", &obj.PrivateRepo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "has_issues", &obj.HasIssues)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceParametersPagerDutyParams : ServiceParametersPagerDutyParams struct
// This model "extends" ServiceParameters
type ServiceParametersPagerDutyParams struct {
	KeyType *string `json:"key_type,omitempty"`

	APIKey *string `json:"api_key,omitempty"`

	ServiceName *string `json:"service_name,omitempty"`

	UserEmail *string `json:"user_email,omitempty"`

	UserPhone *string `json:"user_phone,omitempty"`

	ServiceURL *string `json:"service_url,omitempty"`

	ServiceKey *string `json:"service_key,omitempty"`
}

func (*ServiceParametersPagerDutyParams) isaServiceParameters() bool {
	return true
}

// UnmarshalServiceParametersPagerDutyParams unmarshals an instance of ServiceParametersPagerDutyParams from the specified map of raw messages.
func UnmarshalServiceParametersPagerDutyParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceParametersPagerDutyParams)
	err = core.UnmarshalPrimitive(m, "key_type", &obj.KeyType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "api_key", &obj.APIKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_name", &obj.ServiceName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_email", &obj.UserEmail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user_phone", &obj.UserPhone)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_url", &obj.ServiceURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_key", &obj.ServiceKey)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceParametersPipelineParams : ServiceParametersPipelineParams struct
// This model "extends" ServiceParameters
type ServiceParametersPipelineParams struct {
	Label *string `json:"label,omitempty"`

	Type *string `json:"type,omitempty"`

	Services *string `json:"services,omitempty"`

	Name *string `json:"name,omitempty"`

	Configuration *string `json:"configuration,omitempty"`

	UIPipeline *bool `json:"ui_pipeline,omitempty"`
}

func (*ServiceParametersPipelineParams) isaServiceParameters() bool {
	return true
}

// UnmarshalServiceParametersPipelineParams unmarshals an instance of ServiceParametersPipelineParams from the specified map of raw messages.
func UnmarshalServiceParametersPipelineParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceParametersPipelineParams)
	err = core.UnmarshalPrimitive(m, "label", &obj.Label)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "services", &obj.Services)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "configuration", &obj.Configuration)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ui_pipeline", &obj.UIPipeline)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceParametersSlackParams : ServiceParametersSlackParams struct
// This model "extends" ServiceParameters
type ServiceParametersSlackParams struct {
	APIToken *string `json:"api_token,omitempty"`

	ChannelName *string `json:"channel_name,omitempty"`

	TeamURL *string `json:"team_url,omitempty"`
}

func (*ServiceParametersSlackParams) isaServiceParameters() bool {
	return true
}

// UnmarshalServiceParametersSlackParams unmarshals an instance of ServiceParametersSlackParams from the specified map of raw messages.
func UnmarshalServiceParametersSlackParams(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceParametersSlackParams)
	err = core.UnmarshalPrimitive(m, "api_token", &obj.APIToken)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "channel_name", &obj.ChannelName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "team_url", &obj.TeamURL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}
