/**
 * (C) Copyright IBM Corp. 2021.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * IBM OpenAPI SDK Code Generator Version: 3.32.0-4c6a3129-20210514-210323
 */

// Package opentoolchainv1 : Operations and models for the OpenToolchainV1 service
package opentoolchainv1

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"time"

	"github.com/IBM/go-sdk-core/v5/core"
	common "github.com/dariusbakunas/opentoolchain-go-sdk/common"
	"github.com/go-openapi/strfmt"
)

// OpenToolchainV1 : No description provided (generated by Openapi Generator
// https://github.com/openapitools/openapi-generator)
//
// Version: 1.0.0
type OpenToolchainV1 struct {
	Service *core.BaseService
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://cloud.ibm.com"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "open_toolchain"

// OpenToolchainV1Options : Service options
type OpenToolchainV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator
}

// NewOpenToolchainV1UsingExternalConfig : constructs an instance of OpenToolchainV1 with passed in options and external configuration.
func NewOpenToolchainV1UsingExternalConfig(options *OpenToolchainV1Options) (openToolchain *OpenToolchainV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	openToolchain, err = NewOpenToolchainV1(options)
	if err != nil {
		return
	}

	err = openToolchain.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = openToolchain.Service.SetServiceURL(options.URL)
	}
	return
}

// NewOpenToolchainV1 : constructs an instance of OpenToolchainV1 with passed in options.
func NewOpenToolchainV1(options *OpenToolchainV1Options) (service *OpenToolchainV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	service = &OpenToolchainV1{
		Service: baseService,
	}

	return
}

// GetServiceURLForRegion returns the service URL to be used for the specified region
func GetServiceURLForRegion(region string) (string, error) {
	return "", fmt.Errorf("service does not support regional URLs")
}

// Clone makes a copy of "openToolchain" suitable for processing requests.
func (openToolchain *OpenToolchainV1) Clone() *OpenToolchainV1 {
	if core.IsNil(openToolchain) {
		return nil
	}
	clone := *openToolchain
	clone.Service = openToolchain.Service.Clone()
	return &clone
}

// SetServiceURL sets the service URL
func (openToolchain *OpenToolchainV1) SetServiceURL(url string) error {
	return openToolchain.Service.SetServiceURL(url)
}

// GetServiceURL returns the service URL
func (openToolchain *OpenToolchainV1) GetServiceURL() string {
	return openToolchain.Service.GetServiceURL()
}

// SetDefaultHeaders sets HTTP headers to be sent in every request
func (openToolchain *OpenToolchainV1) SetDefaultHeaders(headers http.Header) {
	openToolchain.Service.SetDefaultHeaders(headers)
}

// SetEnableGzipCompression sets the service's EnableGzipCompression field
func (openToolchain *OpenToolchainV1) SetEnableGzipCompression(enableGzip bool) {
	openToolchain.Service.SetEnableGzipCompression(enableGzip)
}

// GetEnableGzipCompression returns the service's EnableGzipCompression field
func (openToolchain *OpenToolchainV1) GetEnableGzipCompression() bool {
	return openToolchain.Service.GetEnableGzipCompression()
}

// EnableRetries enables automatic retries for requests invoked for this service instance.
// If either parameter is specified as 0, then a default value is used instead.
func (openToolchain *OpenToolchainV1) EnableRetries(maxRetries int, maxRetryInterval time.Duration) {
	openToolchain.Service.EnableRetries(maxRetries, maxRetryInterval)
}

// DisableRetries disables automatic retries for requests invoked for this service instance.
func (openToolchain *OpenToolchainV1) DisableRetries() {
	openToolchain.Service.DisableRetries()
}

// PatchToolchain : Update toolchain parameters
func (openToolchain *OpenToolchainV1) PatchToolchain(patchToolchainOptions *PatchToolchainOptions) (response *core.DetailedResponse, err error) {
	return openToolchain.PatchToolchainWithContext(context.Background(), patchToolchainOptions)
}

// PatchToolchainWithContext is an alternate form of the PatchToolchain method which supports a Context parameter
func (openToolchain *OpenToolchainV1) PatchToolchainWithContext(ctx context.Context, patchToolchainOptions *PatchToolchainOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(patchToolchainOptions, "patchToolchainOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(patchToolchainOptions, "patchToolchainOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"guid": *patchToolchainOptions.GUID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/devops/toolchains/{guid}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range patchToolchainOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "PatchToolchain")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("env_id", fmt.Sprint(*patchToolchainOptions.EnvID))

	body := make(map[string]interface{})
	if patchToolchainOptions.Name != nil {
		body["name"] = patchToolchainOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = openToolchain.Service.Request(request, nil)

	return
}

// DeleteToolchain : The DeleteToolchain operation.
// Delete existing toolchain.
func (openToolchain *OpenToolchainV1) DeleteToolchain(deleteToolchainOptions *DeleteToolchainOptions) (response *core.DetailedResponse, err error) {
	return openToolchain.DeleteToolchainWithContext(context.Background(), deleteToolchainOptions)
}

// DeleteToolchainWithContext is an alternate form of the DeleteToolchain method which supports a Context parameter
func (openToolchain *OpenToolchainV1) DeleteToolchainWithContext(ctx context.Context, deleteToolchainOptions *DeleteToolchainOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteToolchainOptions, "deleteToolchainOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteToolchainOptions, "deleteToolchainOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"guid": *deleteToolchainOptions.GUID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/devops/toolchains/{guid}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteToolchainOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "DeleteToolchain")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddQuery("env_id", fmt.Sprint(*deleteToolchainOptions.EnvID))

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = openToolchain.Service.Request(request, nil)

	return
}

// CreateToolchain : Headless Toolchain Creation/Update using POST
// This info is from the document:-
//   https://github.com/open-toolchain/sdk/wiki/Toolchain-Creation-page-parameters.
func (openToolchain *OpenToolchainV1) CreateToolchain(createToolchainOptions *CreateToolchainOptions) (response *core.DetailedResponse, err error) {
	return openToolchain.CreateToolchainWithContext(context.Background(), createToolchainOptions)
}

// CreateToolchainWithContext is an alternate form of the CreateToolchain method which supports a Context parameter
func (openToolchain *OpenToolchainV1) CreateToolchainWithContext(ctx context.Context, createToolchainOptions *CreateToolchainOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createToolchainOptions, "createToolchainOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createToolchainOptions, "createToolchainOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/devops/setup/deploy`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createToolchainOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "CreateToolchain")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	builder.AddHeader("Content-Type", "application/x-www-form-urlencoded")

	builder.AddQuery("env_id", fmt.Sprint(*createToolchainOptions.EnvID))

	builder.AddFormData("repository", "", "", fmt.Sprint(*createToolchainOptions.Repository))
	if createToolchainOptions.Autocreate != nil {
		builder.AddFormData("autocreate", "", "", fmt.Sprint(*createToolchainOptions.Autocreate))
	}
	if createToolchainOptions.ResourceGroupID != nil {
		builder.AddFormData("resourceGroupId", "", "", fmt.Sprint(*createToolchainOptions.ResourceGroupID))
	}
	if createToolchainOptions.RepositoryToken != nil {
		builder.AddFormData("repository_token", "", "", fmt.Sprint(*createToolchainOptions.RepositoryToken))
	}
	if createToolchainOptions.Branch != nil {
		builder.AddFormData("branch", "", "", fmt.Sprint(*createToolchainOptions.Branch))
	}

	additionalProps := createToolchainOptions.GetProperties()

	if len(additionalProps) > 0 {
		for k, v := range additionalProps {
			builder.AddFormData(k, "", "", v)
		}
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = openToolchain.Service.Request(request, nil)

	return
}

// CreateServiceInstance : Service Instance Creation using POST
func (openToolchain *OpenToolchainV1) CreateServiceInstance(createServiceInstanceOptions *CreateServiceInstanceOptions) (result *CreateServiceInstanceResponse, response *core.DetailedResponse, err error) {
	return openToolchain.CreateServiceInstanceWithContext(context.Background(), createServiceInstanceOptions)
}

// CreateServiceInstanceWithContext is an alternate form of the CreateServiceInstance method which supports a Context parameter
func (openToolchain *OpenToolchainV1) CreateServiceInstanceWithContext(ctx context.Context, createServiceInstanceOptions *CreateServiceInstanceOptions) (result *CreateServiceInstanceResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createServiceInstanceOptions, "createServiceInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createServiceInstanceOptions, "createServiceInstanceOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/devops/service_instances`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createServiceInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "CreateServiceInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("env_id", fmt.Sprint(*createServiceInstanceOptions.EnvID))

	body := make(map[string]interface{})
	if createServiceInstanceOptions.ToolchainID != nil {
		body["toolchainId"] = createServiceInstanceOptions.ToolchainID
	}
	if createServiceInstanceOptions.ServiceID != nil {
		body["serviceId"] = createServiceInstanceOptions.ServiceID
	}
	if createServiceInstanceOptions.Parameters != nil {
		body["parameters"] = createServiceInstanceOptions.Parameters
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = openToolchain.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCreateServiceInstanceResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteServiceInstance : The DeleteServiceInstance operation.
// Delete service instance.
func (openToolchain *OpenToolchainV1) DeleteServiceInstance(deleteServiceInstanceOptions *DeleteServiceInstanceOptions) (response *core.DetailedResponse, err error) {
	return openToolchain.DeleteServiceInstanceWithContext(context.Background(), deleteServiceInstanceOptions)
}

// DeleteServiceInstanceWithContext is an alternate form of the DeleteServiceInstance method which supports a Context parameter
func (openToolchain *OpenToolchainV1) DeleteServiceInstanceWithContext(ctx context.Context, deleteServiceInstanceOptions *DeleteServiceInstanceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteServiceInstanceOptions, "deleteServiceInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteServiceInstanceOptions, "deleteServiceInstanceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"guid": *deleteServiceInstanceOptions.GUID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/devops/service_instances/{guid}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteServiceInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "DeleteServiceInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("env_id", fmt.Sprint(*deleteServiceInstanceOptions.EnvID))

	body := make(map[string]interface{})
	if deleteServiceInstanceOptions.ToolchainID != nil {
		body["toolchainId"] = deleteServiceInstanceOptions.ToolchainID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = openToolchain.Service.Request(request, nil)

	return
}

// PatchServiceInstance : Patch service instance
func (openToolchain *OpenToolchainV1) PatchServiceInstance(patchServiceInstanceOptions *PatchServiceInstanceOptions) (response *core.DetailedResponse, err error) {
	return openToolchain.PatchServiceInstanceWithContext(context.Background(), patchServiceInstanceOptions)
}

// PatchServiceInstanceWithContext is an alternate form of the PatchServiceInstance method which supports a Context parameter
func (openToolchain *OpenToolchainV1) PatchServiceInstanceWithContext(ctx context.Context, patchServiceInstanceOptions *PatchServiceInstanceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(patchServiceInstanceOptions, "patchServiceInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(patchServiceInstanceOptions, "patchServiceInstanceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"guid": *patchServiceInstanceOptions.GUID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/devops/service_instances/{guid}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range patchServiceInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "PatchServiceInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("env_id", fmt.Sprint(*patchServiceInstanceOptions.EnvID))

	body := make(map[string]interface{})
	if patchServiceInstanceOptions.ToolchainID != nil {
		body["toolchainId"] = patchServiceInstanceOptions.ToolchainID
	}
	if patchServiceInstanceOptions.ServiceID != nil {
		body["serviceId"] = patchServiceInstanceOptions.ServiceID
	}
	if patchServiceInstanceOptions.Parameters != nil {
		body["parameters"] = patchServiceInstanceOptions.Parameters
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = openToolchain.Service.Request(request, nil)

	return
}

// GetTektonPipeline : Returns details about a particular tekton pipeline
func (openToolchain *OpenToolchainV1) GetTektonPipeline(getTektonPipelineOptions *GetTektonPipelineOptions) (result *TektonPipeline, response *core.DetailedResponse, err error) {
	return openToolchain.GetTektonPipelineWithContext(context.Background(), getTektonPipelineOptions)
}

// GetTektonPipelineWithContext is an alternate form of the GetTektonPipeline method which supports a Context parameter
func (openToolchain *OpenToolchainV1) GetTektonPipelineWithContext(ctx context.Context, getTektonPipelineOptions *GetTektonPipelineOptions) (result *TektonPipeline, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getTektonPipelineOptions, "getTektonPipelineOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getTektonPipelineOptions, "getTektonPipelineOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"guid": *getTektonPipelineOptions.GUID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/devops/pipelines/tekton/api/v1/{guid}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getTektonPipelineOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "GetTektonPipeline")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("env_id", fmt.Sprint(*getTektonPipelineOptions.EnvID))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = openToolchain.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTektonPipeline)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PatchTektonPipeline : Update tekton pipeline parameters
func (openToolchain *OpenToolchainV1) PatchTektonPipeline(patchTektonPipelineOptions *PatchTektonPipelineOptions) (result *TektonPipeline, response *core.DetailedResponse, err error) {
	return openToolchain.PatchTektonPipelineWithContext(context.Background(), patchTektonPipelineOptions)
}

// PatchTektonPipelineWithContext is an alternate form of the PatchTektonPipeline method which supports a Context parameter
func (openToolchain *OpenToolchainV1) PatchTektonPipelineWithContext(ctx context.Context, patchTektonPipelineOptions *PatchTektonPipelineOptions) (result *TektonPipeline, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(patchTektonPipelineOptions, "patchTektonPipelineOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(patchTektonPipelineOptions, "patchTektonPipelineOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"guid": *patchTektonPipelineOptions.GUID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/devops/pipelines/tekton/api/v1/{guid}/config`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range patchTektonPipelineOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "PatchTektonPipeline")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	builder.AddQuery("env_id", fmt.Sprint(*patchTektonPipelineOptions.EnvID))

	body := make(map[string]interface{})
	if patchTektonPipelineOptions.EnvProperties != nil {
		body["envProperties"] = patchTektonPipelineOptions.EnvProperties
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = openToolchain.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTektonPipeline)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetToolchain : Returns details about a particular toolchain
func (openToolchain *OpenToolchainV1) GetToolchain(getToolchainOptions *GetToolchainOptions) (result *Toolchain, response *core.DetailedResponse, err error) {
	return openToolchain.GetToolchainWithContext(context.Background(), getToolchainOptions)
}

// GetToolchainWithContext is an alternate form of the GetToolchain method which supports a Context parameter
func (openToolchain *OpenToolchainV1) GetToolchainWithContext(ctx context.Context, getToolchainOptions *GetToolchainOptions) (result *Toolchain, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getToolchainOptions, "getToolchainOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getToolchainOptions, "getToolchainOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"guid": *getToolchainOptions.GUID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = openToolchain.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(openToolchain.Service.Options.URL, `/devops/toolchains/{guid}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getToolchainOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("open_toolchain", "V1", "GetToolchain")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("env_id", fmt.Sprint(*getToolchainOptions.EnvID))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = openToolchain.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalToolchain)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// Container : Container struct
type Container struct {
	GUID *string `json:"guid,omitempty"`

	Type *string `json:"type,omitempty"`
}

// UnmarshalContainer unmarshals an instance of Container from the specified map of raw messages.
func UnmarshalContainer(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Container)
	err = core.UnmarshalPrimitive(m, "guid", &obj.GUID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateServiceInstanceOptions : The CreateServiceInstance options.
type CreateServiceInstanceOptions struct {
	// Environment ID.
	EnvID *string `validate:"required"`

	ToolchainID *string

	ServiceID *string

	Parameters *CreateServiceInstanceParamsParameters

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateServiceInstanceOptions : Instantiate CreateServiceInstanceOptions
func (*OpenToolchainV1) NewCreateServiceInstanceOptions(envID string) *CreateServiceInstanceOptions {
	return &CreateServiceInstanceOptions{
		EnvID: core.StringPtr(envID),
	}
}

// SetEnvID : Allow user to set EnvID
func (options *CreateServiceInstanceOptions) SetEnvID(envID string) *CreateServiceInstanceOptions {
	options.EnvID = core.StringPtr(envID)
	return options
}

// SetToolchainID : Allow user to set ToolchainID
func (options *CreateServiceInstanceOptions) SetToolchainID(toolchainID string) *CreateServiceInstanceOptions {
	options.ToolchainID = core.StringPtr(toolchainID)
	return options
}

// SetServiceID : Allow user to set ServiceID
func (options *CreateServiceInstanceOptions) SetServiceID(serviceID string) *CreateServiceInstanceOptions {
	options.ServiceID = core.StringPtr(serviceID)
	return options
}

// SetParameters : Allow user to set Parameters
func (options *CreateServiceInstanceOptions) SetParameters(parameters *CreateServiceInstanceParamsParameters) *CreateServiceInstanceOptions {
	options.Parameters = parameters
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateServiceInstanceOptions) SetHeaders(param map[string]string) *CreateServiceInstanceOptions {
	options.Headers = param
	return options
}

// CreateServiceInstanceParamsParameters : CreateServiceInstanceParamsParameters struct
type CreateServiceInstanceParamsParameters struct {
	Name *string `json:"name" validate:"required"`

	Type *string `json:"type,omitempty"`

	UIPipeline *bool `json:"ui_pipeline,omitempty"`
}

// NewCreateServiceInstanceParamsParameters : Instantiate CreateServiceInstanceParamsParameters (Generic Model Constructor)
func (*OpenToolchainV1) NewCreateServiceInstanceParamsParameters(name string) (model *CreateServiceInstanceParamsParameters, err error) {
	model = &CreateServiceInstanceParamsParameters{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalCreateServiceInstanceParamsParameters unmarshals an instance of CreateServiceInstanceParamsParameters from the specified map of raw messages.
func UnmarshalCreateServiceInstanceParamsParameters(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CreateServiceInstanceParamsParameters)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ui_pipeline", &obj.UIPipeline)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateServiceInstanceResponse : CreateServiceInstanceResponse struct
type CreateServiceInstanceResponse struct {
	Status *string `json:"status,omitempty"`
}

// UnmarshalCreateServiceInstanceResponse unmarshals an instance of CreateServiceInstanceResponse from the specified map of raw messages.
func UnmarshalCreateServiceInstanceResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CreateServiceInstanceResponse)
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateToolchainOptions : The CreateToolchain options.
type CreateToolchainOptions struct {
	// Environment ID.
	EnvID *string `validate:"required"`

	// The URL of the Git repository containing the template.
	// (For example:- https://github.com/open-toolchain/simple-toolchain).
	Repository *string `validate:"required"`

	// If this param is not provided, then the creation will be ignored and it will just load the toolchain creation page.
	Autocreate *bool

	// The GUID of resource group where toolchain will be created. Pass this parameter, if you want to create the toolchain
	// inside the resource group instead of an org.
	ResourceGroupID *string

	// Optional git api token to access template repository.
	RepositoryToken *string

	// The Git branch name that the template will be read from. Optional. Defaults to `master`.
	Branch *string

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}

	// Allows users to set headers on API requests
	Headers map[string]string
}

// SetProperty allows the user to set an arbitrary property on an instance of CreateToolchainParams
func (o *CreateToolchainOptions) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of CreateToolchainParams
func (o *CreateToolchainOptions) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// NewCreateToolchainOptions : Instantiate CreateToolchainOptions
func (*OpenToolchainV1) NewCreateToolchainOptions(envID string, repository string) *CreateToolchainOptions {
	return &CreateToolchainOptions{
		EnvID:      core.StringPtr(envID),
		Repository: core.StringPtr(repository),
	}
}

// SetEnvID : Allow user to set EnvID
func (options *CreateToolchainOptions) SetEnvID(envID string) *CreateToolchainOptions {
	options.EnvID = core.StringPtr(envID)
	return options
}

// SetRepository : Allow user to set Repository
func (options *CreateToolchainOptions) SetRepository(repository string) *CreateToolchainOptions {
	options.Repository = core.StringPtr(repository)
	return options
}

// SetAutocreate : Allow user to set Autocreate
func (options *CreateToolchainOptions) SetAutocreate(autocreate bool) *CreateToolchainOptions {
	options.Autocreate = core.BoolPtr(autocreate)
	return options
}

// SetResourceGroupID : Allow user to set ResourceGroupID
func (options *CreateToolchainOptions) SetResourceGroupID(resourceGroupID string) *CreateToolchainOptions {
	options.ResourceGroupID = core.StringPtr(resourceGroupID)
	return options
}

// SetRepositoryToken : Allow user to set RepositoryToken
func (options *CreateToolchainOptions) SetRepositoryToken(repositoryToken string) *CreateToolchainOptions {
	options.RepositoryToken = core.StringPtr(repositoryToken)
	return options
}

// SetBranch : Allow user to set Branch
func (options *CreateToolchainOptions) SetBranch(branch string) *CreateToolchainOptions {
	options.Branch = core.StringPtr(branch)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateToolchainOptions) SetHeaders(param map[string]string) *CreateToolchainOptions {
	options.Headers = param
	return options
}

// DeleteServiceInstanceOptions : The DeleteServiceInstance options.
type DeleteServiceInstanceOptions struct {
	// GUID of the service instance.
	GUID *string `validate:"required,ne="`

	// Environment ID.
	EnvID *string `validate:"required"`

	ToolchainID *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteServiceInstanceOptions : Instantiate DeleteServiceInstanceOptions
func (*OpenToolchainV1) NewDeleteServiceInstanceOptions(guid string, envID string) *DeleteServiceInstanceOptions {
	return &DeleteServiceInstanceOptions{
		GUID:  core.StringPtr(guid),
		EnvID: core.StringPtr(envID),
	}
}

// SetGUID : Allow user to set GUID
func (options *DeleteServiceInstanceOptions) SetGUID(guid string) *DeleteServiceInstanceOptions {
	options.GUID = core.StringPtr(guid)
	return options
}

// SetEnvID : Allow user to set EnvID
func (options *DeleteServiceInstanceOptions) SetEnvID(envID string) *DeleteServiceInstanceOptions {
	options.EnvID = core.StringPtr(envID)
	return options
}

// SetToolchainID : Allow user to set ToolchainID
func (options *DeleteServiceInstanceOptions) SetToolchainID(toolchainID string) *DeleteServiceInstanceOptions {
	options.ToolchainID = core.StringPtr(toolchainID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteServiceInstanceOptions) SetHeaders(param map[string]string) *DeleteServiceInstanceOptions {
	options.Headers = param
	return options
}

// DeleteToolchainOptions : The DeleteToolchain options.
type DeleteToolchainOptions struct {
	// GUID of the toolchain.
	GUID *string `validate:"required,ne="`

	// Environment ID.
	EnvID *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteToolchainOptions : Instantiate DeleteToolchainOptions
func (*OpenToolchainV1) NewDeleteToolchainOptions(guid string, envID string) *DeleteToolchainOptions {
	return &DeleteToolchainOptions{
		GUID:  core.StringPtr(guid),
		EnvID: core.StringPtr(envID),
	}
}

// SetGUID : Allow user to set GUID
func (options *DeleteToolchainOptions) SetGUID(guid string) *DeleteToolchainOptions {
	options.GUID = core.StringPtr(guid)
	return options
}

// SetEnvID : Allow user to set EnvID
func (options *DeleteToolchainOptions) SetEnvID(envID string) *DeleteToolchainOptions {
	options.EnvID = core.StringPtr(envID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteToolchainOptions) SetHeaders(param map[string]string) *DeleteToolchainOptions {
	options.Headers = param
	return options
}

// EnvProperty : EnvProperty struct
type EnvProperty struct {
	Name *string `json:"name" validate:"required"`

	Value *string `json:"value" validate:"required"`

	Type *string `json:"type" validate:"required"`
}

// NewEnvProperty : Instantiate EnvProperty (Generic Model Constructor)
func (*OpenToolchainV1) NewEnvProperty(name string, value string, typeVar string) (model *EnvProperty, err error) {
	model = &EnvProperty{
		Name:  core.StringPtr(name),
		Value: core.StringPtr(value),
		Type:  core.StringPtr(typeVar),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalEnvProperty unmarshals an instance of EnvProperty from the specified map of raw messages.
func UnmarshalEnvProperty(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EnvProperty)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetTektonPipelineOptions : The GetTektonPipeline options.
type GetTektonPipelineOptions struct {
	// GUID of the pipeline.
	GUID *string `validate:"required,ne="`

	// Environment ID.
	EnvID *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetTektonPipelineOptions : Instantiate GetTektonPipelineOptions
func (*OpenToolchainV1) NewGetTektonPipelineOptions(guid string, envID string) *GetTektonPipelineOptions {
	return &GetTektonPipelineOptions{
		GUID:  core.StringPtr(guid),
		EnvID: core.StringPtr(envID),
	}
}

// SetGUID : Allow user to set GUID
func (options *GetTektonPipelineOptions) SetGUID(guid string) *GetTektonPipelineOptions {
	options.GUID = core.StringPtr(guid)
	return options
}

// SetEnvID : Allow user to set EnvID
func (options *GetTektonPipelineOptions) SetEnvID(envID string) *GetTektonPipelineOptions {
	options.EnvID = core.StringPtr(envID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetTektonPipelineOptions) SetHeaders(param map[string]string) *GetTektonPipelineOptions {
	options.Headers = param
	return options
}

// GetToolchainOptions : The GetToolchain options.
type GetToolchainOptions struct {
	// GUID of the toolchain.
	GUID *string `validate:"required,ne="`

	// Environment ID.
	EnvID *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetToolchainOptions : Instantiate GetToolchainOptions
func (*OpenToolchainV1) NewGetToolchainOptions(guid string, envID string) *GetToolchainOptions {
	return &GetToolchainOptions{
		GUID:  core.StringPtr(guid),
		EnvID: core.StringPtr(envID),
	}
}

// SetGUID : Allow user to set GUID
func (options *GetToolchainOptions) SetGUID(guid string) *GetToolchainOptions {
	options.GUID = core.StringPtr(guid)
	return options
}

// SetEnvID : Allow user to set EnvID
func (options *GetToolchainOptions) SetEnvID(envID string) *GetToolchainOptions {
	options.EnvID = core.StringPtr(envID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetToolchainOptions) SetHeaders(param map[string]string) *GetToolchainOptions {
	options.Headers = param
	return options
}

// PatchServiceInstanceOptions : The PatchServiceInstance options.
type PatchServiceInstanceOptions struct {
	// GUID of the instance.
	GUID *string `validate:"required,ne="`

	// Environment ID.
	EnvID *string `validate:"required"`

	ToolchainID *string

	ServiceID *string

	Parameters *CreateServiceInstanceParamsParameters

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPatchServiceInstanceOptions : Instantiate PatchServiceInstanceOptions
func (*OpenToolchainV1) NewPatchServiceInstanceOptions(guid string, envID string) *PatchServiceInstanceOptions {
	return &PatchServiceInstanceOptions{
		GUID:  core.StringPtr(guid),
		EnvID: core.StringPtr(envID),
	}
}

// SetGUID : Allow user to set GUID
func (options *PatchServiceInstanceOptions) SetGUID(guid string) *PatchServiceInstanceOptions {
	options.GUID = core.StringPtr(guid)
	return options
}

// SetEnvID : Allow user to set EnvID
func (options *PatchServiceInstanceOptions) SetEnvID(envID string) *PatchServiceInstanceOptions {
	options.EnvID = core.StringPtr(envID)
	return options
}

// SetToolchainID : Allow user to set ToolchainID
func (options *PatchServiceInstanceOptions) SetToolchainID(toolchainID string) *PatchServiceInstanceOptions {
	options.ToolchainID = core.StringPtr(toolchainID)
	return options
}

// SetServiceID : Allow user to set ServiceID
func (options *PatchServiceInstanceOptions) SetServiceID(serviceID string) *PatchServiceInstanceOptions {
	options.ServiceID = core.StringPtr(serviceID)
	return options
}

// SetParameters : Allow user to set Parameters
func (options *PatchServiceInstanceOptions) SetParameters(parameters *CreateServiceInstanceParamsParameters) *PatchServiceInstanceOptions {
	options.Parameters = parameters
	return options
}

// SetHeaders : Allow user to set Headers
func (options *PatchServiceInstanceOptions) SetHeaders(param map[string]string) *PatchServiceInstanceOptions {
	options.Headers = param
	return options
}

// PatchTektonPipelineOptions : The PatchTektonPipeline options.
type PatchTektonPipelineOptions struct {
	// GUID of the pipeline.
	GUID *string `validate:"required,ne="`

	// Environment ID.
	EnvID *string `validate:"required"`

	EnvProperties []EnvProperty

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPatchTektonPipelineOptions : Instantiate PatchTektonPipelineOptions
func (*OpenToolchainV1) NewPatchTektonPipelineOptions(guid string, envID string) *PatchTektonPipelineOptions {
	return &PatchTektonPipelineOptions{
		GUID:  core.StringPtr(guid),
		EnvID: core.StringPtr(envID),
	}
}

// SetGUID : Allow user to set GUID
func (options *PatchTektonPipelineOptions) SetGUID(guid string) *PatchTektonPipelineOptions {
	options.GUID = core.StringPtr(guid)
	return options
}

// SetEnvID : Allow user to set EnvID
func (options *PatchTektonPipelineOptions) SetEnvID(envID string) *PatchTektonPipelineOptions {
	options.EnvID = core.StringPtr(envID)
	return options
}

// SetEnvProperties : Allow user to set EnvProperties
func (options *PatchTektonPipelineOptions) SetEnvProperties(envProperties []EnvProperty) *PatchTektonPipelineOptions {
	options.EnvProperties = envProperties
	return options
}

// SetHeaders : Allow user to set Headers
func (options *PatchTektonPipelineOptions) SetHeaders(param map[string]string) *PatchTektonPipelineOptions {
	options.Headers = param
	return options
}

// PatchToolchainOptions : The PatchToolchain options.
type PatchToolchainOptions struct {
	// GUID of the toolchain.
	GUID *string `validate:"required,ne="`

	// Environment ID.
	EnvID *string `validate:"required"`

	// Toolchain name.
	Name *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPatchToolchainOptions : Instantiate PatchToolchainOptions
func (*OpenToolchainV1) NewPatchToolchainOptions(guid string, envID string) *PatchToolchainOptions {
	return &PatchToolchainOptions{
		GUID:  core.StringPtr(guid),
		EnvID: core.StringPtr(envID),
	}
}

// SetGUID : Allow user to set GUID
func (options *PatchToolchainOptions) SetGUID(guid string) *PatchToolchainOptions {
	options.GUID = core.StringPtr(guid)
	return options
}

// SetEnvID : Allow user to set EnvID
func (options *PatchToolchainOptions) SetEnvID(envID string) *PatchToolchainOptions {
	options.EnvID = core.StringPtr(envID)
	return options
}

// SetName : Allow user to set Name
func (options *PatchToolchainOptions) SetName(name string) *PatchToolchainOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *PatchToolchainOptions) SetHeaders(param map[string]string) *PatchToolchainOptions {
	options.Headers = param
	return options
}

// Service : Service struct
type Service struct {
	BrokerID *string `json:"broker_id,omitempty"`

	ServiceID *string `json:"service_id" validate:"required"`

	Container *Container `json:"container,omitempty"`

	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	Parameters map[string]interface{} `json:"parameters,omitempty"`

	Status *ServiceStatus `json:"status,omitempty"`

	DashboardURL *string `json:"dashboard_url,omitempty"`

	RegionID *string `json:"region_id,omitempty"`

	InstanceID *string `json:"instance_id,omitempty"`

	Description *string `json:"description,omitempty"`

	Tags []string `json:"tags,omitempty"`

	URL *string `json:"url,omitempty"`

	ToolchainBinding *ServiceToolchainBinding `json:"toolchain_binding,omitempty"`
}

// UnmarshalService unmarshals an instance of Service from the specified map of raw messages.
func UnmarshalService(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Service)
	err = core.UnmarshalPrimitive(m, "broker_id", &obj.BrokerID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_id", &obj.ServiceID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "container", &obj.Container, UnmarshalContainer)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "parameters", &obj.Parameters)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "status", &obj.Status, UnmarshalServiceStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dashboard_url", &obj.DashboardURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region_id", &obj.RegionID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instance_id", &obj.InstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tags", &obj.Tags)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "toolchain_binding", &obj.ToolchainBinding, UnmarshalServiceToolchainBinding)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceStatus : ServiceStatus struct
type ServiceStatus struct {
	State *string `json:"state,omitempty"`
}

// UnmarshalServiceStatus unmarshals an instance of ServiceStatus from the specified map of raw messages.
func UnmarshalServiceStatus(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceStatus)
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceToolchainBinding : ServiceToolchainBinding struct
type ServiceToolchainBinding struct {
	Status *ServiceToolchainBindingStatus `json:"status,omitempty"`

	Name *string `json:"name,omitempty"`

	WebhookID *string `json:"webhook_id,omitempty"`
}

// UnmarshalServiceToolchainBinding unmarshals an instance of ServiceToolchainBinding from the specified map of raw messages.
func UnmarshalServiceToolchainBinding(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceToolchainBinding)
	err = core.UnmarshalModel(m, "status", &obj.Status, UnmarshalServiceToolchainBindingStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "webhook_id", &obj.WebhookID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceToolchainBindingStatus : ServiceToolchainBindingStatus struct
type ServiceToolchainBindingStatus struct {
	State *string `json:"state,omitempty"`
}

// UnmarshalServiceToolchainBindingStatus unmarshals an instance of ServiceToolchainBindingStatus from the specified map of raw messages.
func UnmarshalServiceToolchainBindingStatus(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceToolchainBindingStatus)
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TektonPipeline : TektonPipeline struct
type TektonPipeline struct {
	Name *string `json:"name" validate:"required"`

	ID *string `json:"id" validate:"required"`

	ToolchainID *string `json:"toolchainId" validate:"required"`

	PipelineOwner *string `json:"pipelineOwner,omitempty"`

	Enabled *bool `json:"enabled,omitempty"`

	Type *string `json:"type,omitempty"`

	Created *strfmt.DateTime `json:"created,omitempty"`

	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	UpdatedAtTimestamp *float64 `json:"updated_at_timestamp,omitempty"`

	CreatedTimestamp *float64 `json:"created_timestamp,omitempty"`

	EnvProperties []EnvProperty `json:"envProperties" validate:"required"`

	Status *string `json:"status,omitempty"`

	URL *string `json:"url,omitempty"`

	RunsURL *string `json:"runs_url,omitempty"`

	ToolchainCRN *string `json:"toolchainCRN,omitempty"`

	PipelineDefinitionID *string `json:"pipelineDefinitionId,omitempty"`
}

// UnmarshalTektonPipeline unmarshals an instance of TektonPipeline from the specified map of raw messages.
func UnmarshalTektonPipeline(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TektonPipeline)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "toolchainId", &obj.ToolchainID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pipelineOwner", &obj.PipelineOwner)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created", &obj.Created)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at_timestamp", &obj.UpdatedAtTimestamp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_timestamp", &obj.CreatedTimestamp)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "envProperties", &obj.EnvProperties, UnmarshalEnvProperty)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "runs_url", &obj.RunsURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "toolchainCRN", &obj.ToolchainCRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pipelineDefinitionId", &obj.PipelineDefinitionID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Toolchain : Toolchain struct
type Toolchain struct {
	ToolchainGUID *string `json:"toolchain_guid" validate:"required"`

	Name *string `json:"name" validate:"required"`

	Description *string `json:"description,omitempty"`

	Key *string `json:"key,omitempty"`

	Container *Container `json:"container,omitempty"`

	CRN *string `json:"crn,omitempty"`

	Created *strfmt.DateTime `json:"created,omitempty"`

	UpdatedAt *strfmt.DateTime `json:"updated_at,omitempty"`

	Creator *string `json:"creator,omitempty"`

	Generator *string `json:"generator,omitempty"`

	Template *ToolchainTemplate `json:"template,omitempty"`

	Tags []string `json:"tags,omitempty"`

	LifecycleMessagingWebhookID *string `json:"lifecycle_messaging_webhook_id,omitempty"`

	RegionID *string `json:"region_id,omitempty"`

	Services []Service `json:"services,omitempty"`
}

// UnmarshalToolchain unmarshals an instance of Toolchain from the specified map of raw messages.
func UnmarshalToolchain(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Toolchain)
	err = core.UnmarshalPrimitive(m, "toolchain_guid", &obj.ToolchainGUID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "key", &obj.Key)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "container", &obj.Container, UnmarshalContainer)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created", &obj.Created)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated_at", &obj.UpdatedAt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "creator", &obj.Creator)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "generator", &obj.Generator)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "template", &obj.Template, UnmarshalToolchainTemplate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tags", &obj.Tags)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lifecycle_messaging_webhook_id", &obj.LifecycleMessagingWebhookID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region_id", &obj.RegionID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "services", &obj.Services, UnmarshalService)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ToolchainTemplate : ToolchainTemplate struct
type ToolchainTemplate struct {
	GettingStarted *string `json:"getting_started,omitempty"`

	ServicesTotal *int64 `json:"services_total,omitempty"`

	Name *string `json:"name,omitempty"`

	Type *string `json:"type,omitempty"`

	URL *string `json:"url,omitempty"`

	Source *string `json:"source,omitempty"`

	Locale *string `json:"locale,omitempty"`
}

// UnmarshalToolchainTemplate unmarshals an instance of ToolchainTemplate from the specified map of raw messages.
func UnmarshalToolchainTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ToolchainTemplate)
	err = core.UnmarshalPrimitive(m, "getting_started", &obj.GettingStarted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "services_total", &obj.ServicesTotal)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "locale", &obj.Locale)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}
